# -*- coding: utf-8 -*-
"""java-air-combat.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sIal2F7cbCfQ5GQ9NHVTBRAq7vpKSCXU
"""

!apt-get install openjdk-11-jdk-headless -qq > /dev/null

!pip install gradio

# Commented out IPython magic to ensure Python compatibility.
# %%writefile AsciiCombat.java
# import java.util.Random;
# 
# abstract class Aircraft {
#     protected int health = 100;
#     protected int speed = 5;
#     protected int fireRate = 1;
#     protected int missilePower = 20;
#     protected int maneuverability = 5;
#     protected String symbol;
# 
#     public abstract int move();
#     public abstract int shoot();
# 
#     public void takeDamage(int damage) {
#         this.health -= damage;
#     }
# 
#     public boolean isAlive() {
#         return this.health > 0;
#     }
# }
# 
# // Aeronave 1 (Esquerda) >
# class FalconX extends Aircraft {
#     public FalconX() {
#         this.speed = 7;
#         this.fireRate = 2;
#         this.missilePower = 15;
#         this.maneuverability = 6;
#          this.symbol = "‚ñ∂";  // ASCII para avi√£o virado para a direita
#     }
# 
#     public int move() {
#         return new Random().nextInt(3) - 1;  // -1, 0 ou +1
#     }
# 
#     public int shoot() {
#         return new Random().nextInt(5) + 1;  // Tiros de 1 a 5 posi√ß√µes
#     }
# }
# 
# // Aeronave 2 (Direita) <
# class ThunderJet extends Aircraft {
#     public ThunderJet() {
#         this.speed = 6;
#         this.fireRate = 3;
#         this.missilePower = 20;
#         this.maneuverability = 7;
#         this.symbol = "‚óÄ";  // ASCII para avi√£o virado para a esquerda
#     }
# 
#     public int move() {
#         return new Random().nextInt(3) - 1;
#     }
# 
#     public int shoot() {
#         return new Random().nextInt(5) + 1;
#     }
# }
# 
# // Simula√ß√£o do Combate
# public class AsciiCombat {
#     public static void battle(Aircraft p1, Aircraft p2) {
#         int p1Pos = 2;
#         int p2Pos = 18;
#         int screenWidth = 50;
# 
#         while (p1.isAlive() && p2.isAlive()) {
#             System.out.println("\n=== NOVO TURNO ===");
# 
#             // Movimentos das aeronaves
#             p1Pos += p1.move();
#             p2Pos += p2.move();
#             p1Pos = Math.max(0, Math.min(screenWidth - 1, p1Pos));
#             p2Pos = Math.max(0, Math.min(screenWidth - 1, p2Pos));
# 
#             // Criando o campo de batalha
#             String[] battlefield = new String[screenWidth];
#             for (int i = 0; i < screenWidth; i++) battlefield[i] = " ";
# 
#             battlefield[p1Pos] = p1.symbol;  // Aeronave 1 >
#             battlefield[p2Pos] = p2.symbol;  // Aeronave 2 <
# 
#             // Disparos
#             int p1Shot = p1Pos + p1.shoot();
#             int p2Shot = p2Pos - p2.shoot();
# 
#             if (p1Shot >= screenWidth) p1Shot = screenWidth - 1;
#             if (p2Shot < 0) p2Shot = 0;
# 
#             if (p1Shot != p1Pos) battlefield[p1Shot] = "->";  // Tiro da esquerda
#             if (p2Shot != p2Pos) battlefield[p2Shot] = "<-";  // Tiro da direita
# 
#             // Mostrar o campo de batalha
#             for (int i = 0; i < screenWidth; i++) {
#                 System.out.print(battlefield[i]);
#             }
#             System.out.println();
# 
#             // Verificar se houve acerto
#             if (p1Shot == p2Pos) {
#                 System.out.println("# Equipe 1 acertou a Equipe 2!");
#                 p2.takeDamage(p1.fireRate * 5);
#             }
# 
#             if (p2Shot == p1Pos) {
#                 System.out.println("X Equipe 2 acertou a Equipe 1!");
#                 p1.takeDamage(p2.fireRate * 5);
#             }
# 
#             // Vida das aeronaves
#             System.out.println("Vida P1: " + p1.health + " | Vida P2: " + p2.health);
# 
#             // Pausa para simular anima√ß√£o
#             try { Thread.sleep(1000); } catch (InterruptedException e) {}
#         }
# 
#         System.out.println("\n=== FIM DA BATALHA ===");
#         if (p1.isAlive()) {
#             System.out.println("Equipe 1 venceu!");
#         } else {
#             System.out.println("Equipe 2 venceu!");
#         }
#     }
# 
#     public static void main(String[] args) {
#         Aircraft team1 = new FalconX();
#         Aircraft team2 = new ThunderJet();
# 
#         battle(team1, team2);
#     }
# }
#

!javac AsciiCombat.java
!java AsciiCombat

# Commented out IPython magic to ensure Python compatibility.
# %%writefile AsciiCombat.java
# import java.util.Random;
# import java.util.Scanner;
# 
# abstract class Aircraft {
#     protected int health;
#     protected int speed;
#     protected int fireRate;
#     protected int missilePower;
#     protected int maneuverability;
#     protected String symbol;
#     protected int positionY;  // 0 = TOP, 1 = MIDDLE, 2 = BOTTOM
# 
#     public abstract int move();
#     public abstract int shoot();
#     public abstract int changeAltitude();
# 
#     public void takeDamage(int damage) {
#         this.health -= damage;
#     }
# 
#     public boolean isAlive() {
#         return this.health > 0;
#     }
# }
# 
# // Classe para distribuir pontos
# class AircraftConfig {
#     public static Aircraft createAircraft(String name, String symbol) {
#         Scanner scanner = new Scanner(System.in);
#         int totalPoints = 20;  // Pontos dispon√≠veis para distribuir
# 
#         System.out.println("\nConfigura√ß√£o da aeronave " + name);
#         System.out.println("Voc√™ tem " + totalPoints + " pontos para distribuir.");
# 
#         System.out.print("Velocidade (0-10): ");
#         int speed = scanner.nextInt();
#         totalPoints -= speed;
# 
#         System.out.print("Taxa de Tiro (0-10): ");
#         int fireRate = scanner.nextInt();
#         totalPoints -= fireRate;
# 
#         System.out.print("Poder do M√≠ssil (0-10): ");
#         int missilePower = scanner.nextInt();
#         totalPoints -= missilePower;
# 
#         System.out.print("Manobrabilidade (0-10): ");
#         int maneuverability = totalPoints;  // O que sobrar vai para manobrabilidade
# 
#         return new CustomAircraft(name, symbol, speed, fireRate, missilePower, maneuverability);
#     }
# }
# 
# // Aeronave Customizada
# class CustomAircraft extends Aircraft {
#     private Random random = new Random();
# 
#     public CustomAircraft(String name, String symbol, int speed, int fireRate, int missilePower, int maneuverability) {
#         this.health = 100;
#         this.speed = speed;
#         this.fireRate = fireRate;
#         this.missilePower = missilePower;
#         this.maneuverability = maneuverability;
#         this.symbol = symbol;
#         this.positionY = 1;  // Come√ßa no meio
#     }
# 
#     public int move() {
#         return random.nextInt(speed + 1) - speed / 2;
#     }
# 
#     public int shoot() {
#         return random.nextInt(fireRate + 1);
#     }
# 
#     public int changeAltitude() {
#         int direction = random.nextInt(3) - 1;  // -1 = sobe, 0 = mant√©m, 1 = desce
#         positionY = Math.max(0, Math.min(2, positionY + direction));
#         return direction;
#     }
# }
# 
# // Simula√ß√£o do Combate com 3 Linhas
# public class AsciiCombat {
#     public static void battle(Aircraft p1, Aircraft p2) {
#         int p1PosX = 2;
#         int p2PosX = 47;
#         int screenWidth = 50;
# 
#         while (p1.isAlive() && p2.isAlive()) {
#             System.out.println("\n=== NOVO TURNO ===");
# 
#             // Movimenta√ß√£o Horizontal e Vertical
#             p1PosX += p1.move();
#             p2PosX += p2.move();
#             p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
#             p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));
# 
#             int p1AltChange = p1.changeAltitude();
#             int p2AltChange = p2.changeAltitude();
# 
#             // Campo de batalha com 3 linhas
#             String[][] battlefield = {new String[screenWidth], new String[screenWidth], new String[screenWidth]};
#             for (int i = 0; i < screenWidth; i++) {
#                 battlefield[0][i] = " ";
#                 battlefield[1][i] = " ";
#                 battlefield[2][i] = " ";
#             }
# 
#             // Posiciona as aeronaves
#             battlefield[p1.positionY][p1PosX] = p1.symbol;
#             battlefield[p2.positionY][p2PosX] = p2.symbol;
# 
#             // Disparos
#             int p1ShotX = p1PosX + p1.shoot();
#             int p2ShotX = p2PosX - p2.shoot();
# 
#             if (p1ShotX >= screenWidth) p1ShotX = screenWidth - 1;
#             if (p2ShotX < 0) p2ShotX = 0;
# 
#             // Verificar se os tiros atingem a mesma linha do oponente
#             if (p1ShotX != p1PosX) battlefield[p1.positionY][p1ShotX] = "->";
#             if (p2ShotX != p2PosX) battlefield[p2.positionY][p2ShotX] = "<-";
# 
#             // Mostrar o campo de batalha
#             for (int row = 0; row < 3; row++) {
#                 for (int i = 0; i < screenWidth; i++) {
#                     System.out.print(battlefield[row][i]);
#                 }
#                 System.out.println();
#             }
# 
#             // Verificar se houve acerto ou desvio
#             if (p1ShotX == p2PosX && p1.positionY == p2.positionY) {
#                 System.out.println("# Equipe 1 acertou a Equipe 2!");
#                 p2.takeDamage(p1.fireRate * 5);
#             } else if (p1ShotX == p2PosX) {
#                 System.out.println("Equipe 2 conseguiu desviar do ataque!");
#             }
# 
#             if (p2ShotX == p1PosX && p2.positionY == p1.positionY) {
#                 System.out.println("X Equipe 2 acertou a Equipe 1!");
#                 p1.takeDamage(p2.fireRate * 5);
#             } else if (p2ShotX == p1PosX) {
#                 System.out.println("Equipe 1 conseguiu desviar do ataque!");
#             }
# 
#             // Vida das aeronaves
#             System.out.println("Vida P1: " + p1.health + " | Vida P2: " + p2.health);
# 
#             // Pausa para simular anima√ß√£o
#             try { Thread.sleep(1000); } catch (InterruptedException e) {}
#         }
# 
#         System.out.println("\n=== FIM DA BATALHA ===");
#         if (p1.isAlive()) {
#             System.out.println("Equipe 1 venceu!");
#         } else {
#             System.out.println("Equipe 2 venceu!");
#         }
#     }
# 
#     public static void main(String[] args) {
#         Aircraft team1 = AircraftConfig.createAircraft("Equipe 1", ">");
#         Aircraft team2 = AircraftConfig.createAircraft("Equipe 2", "<");
# 
#         battle(team1, team2);
#     }
# }
#

!javac AsciiCombat.java
!java AsciiCombat

# Commented out IPython magic to ensure Python compatibility.
# %%writefile AsciiCombat.java
# import java.util.Random;
# 
# abstract class Aircraft {
#     protected int health;
#     protected int speed;
#     protected int fireRate;
#     protected int missilePower;
#     protected int maneuverability;
#     protected String symbol;
#     protected int positionY;  // 0 = TOP, 1 = MIDDLE, 2 = BOTTOM
# 
#     public abstract int move();
#     public abstract int shoot();
#     public abstract int changeAltitude();
# 
#     public void takeDamage(int damage) {
#         this.health -= damage;
#     }
# 
#     public boolean isAlive() {
#         return this.health > 0;
#     }
# }
# 
# // Aeronave configur√°vel diretamente no c√≥digo
# class CustomAircraft extends Aircraft {
#     private Random random = new Random();
# 
#     public CustomAircraft(String symbol, int speed, int fireRate, int missilePower, int maneuverability) {
#         this.health = 100;
#         this.speed = speed;
#         this.fireRate = fireRate;
#         this.missilePower = missilePower;
#         this.maneuverability = maneuverability;
#         this.symbol = symbol;
#         this.positionY = 1;  // Come√ßa no meio
#     }
# 
#     public int move() {
#         return random.nextInt(speed + 1) - speed / 2;
#     }
# 
#     public int shoot() {
#         return fireRate;  // Agora os tiros seguem em linha reta
#     }
# 
#     public int changeAltitude() {
#         int direction = random.nextInt(3) - 1;  // -1 = sobe, 0 = mant√©m, 1 = desce
#         positionY = Math.max(0, Math.min(2, positionY + direction));
#         return direction;
#     }
# }
# 
# // Simula√ß√£o do Combate com Tiros Persistentes
# public class AsciiCombat {
#     public static void battle(Aircraft p1, Aircraft p2) {
#         int p1PosX = 2;
#         int p2PosX = 47;
#         int screenWidth = 50;
# 
#         // Arrays para armazenar a posi√ß√£o dos tiros
#         String[][] battlefield = new String[3][screenWidth];
# 
#         while (p1.isAlive() && p2.isAlive()) {
#             System.out.println("\n=== NOVO TURNO ===");
# 
#             // Limpa o campo de batalha
#             for (int row = 0; row < 3; row++) {
#                 for (int i = 0; i < screenWidth; i++) {
#                     battlefield[row][i] = " ";
#                 }
#             }
# 
#             // Movimenta√ß√£o Horizontal e Vertical
#             p1PosX += p1.move();
#             p2PosX += p2.move();
#             p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
#             p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));
# 
#             int p1AltChange = p1.changeAltitude();
#             int p2AltChange = p2.changeAltitude();
# 
#             // Posiciona as aeronaves
#             battlefield[p1.positionY][p1PosX] = p1.symbol;
#             battlefield[p2.positionY][p2PosX] = p2.symbol;
# 
#             // Disparos - Agora os tiros viajam por toda a tela
#             for (int i = p1PosX + 1; i < screenWidth; i++) {
#                 battlefield[p1.positionY][i] = "-";  // Tiro da esquerda para a direita
#             }
#             for (int i = p2PosX - 1; i >= 0; i--) {
#                 battlefield[p2.positionY][i] = "*";  // Tiro da direita para a esquerda
#             }
# 
#             // Mostrar o campo de batalha
#             for (int row = 0; row < 3; row++) {
#                 for (int i = 0; i < screenWidth; i++) {
#                     System.out.print(battlefield[row][i]);
#                 }
#                 System.out.println();
#             }
# 
#             // Verificar se houve acerto
#             if (p1PosX < p2PosX && p1.positionY == p2.positionY) {
#                 System.out.println("# Equipe 1 acertou a Equipe 2!");
#                 p2.takeDamage(p1.fireRate * 5);
#             }
# 
#             if (p2PosX > p1PosX && p2.positionY == p1.positionY) {
#                 System.out.println("X Equipe 2 acertou a Equipe 1!");
#                 p1.takeDamage(p2.fireRate * 5);
#             }
# 
#             // Vida das aeronaves
#             System.out.println("Vida P1: " + p1.health + " | Vida P2: " + p2.health);
# 
#             // Pausa para simular anima√ß√£o
#             try { Thread.sleep(1000); } catch (InterruptedException e) {}
#         }
# 
#         System.out.println("\n=== FIM DA BATALHA ===");
#         if (p1.isAlive()) {
#             System.out.println("Equipe 1 venceu!");
#         } else {
#             System.out.println("Equipe 2 venceu!");
#         }
#     }
# 
#     public static void main(String[] args) {
#         // Configura√ß√£o manual das aeronaves
#         Aircraft team1 = new CustomAircraft(">", 7, 3, 5, 5);  // (S√≠mbolo, Velocidade, Taxa de Tiro, Poder do M√≠ssil, Manobrabilidade)
#         Aircraft team2 = new CustomAircraft("<", 5, 5, 3, 7);  // Configura√ß√£o personalizada
# 
#         battle(team1, team2);
#     }
# }
#

!javac AsciiCombat.java
!java AsciiCombat

# Commented out IPython magic to ensure Python compatibility.
# %%writefile AsciiCombat.java
# import java.util.Random;
# import java.util.ArrayList;
# import java.util.Iterator;
# 
# // Classe para representar um tiro
# class Projectile {
#     int posX;
#     int posY;
#     int direction; // 1 para a direita, -1 para a esquerda
#     String symbol;
# 
#     public Projectile(int posX, int posY, int direction, String symbol) {
#         this.posX = posX;
#         this.posY = posY;
#         this.direction = direction;
#         this.symbol = symbol;
#     }
# 
#     public void move() {
#         posX += direction;
#     }
# 
#     public boolean isOutOfBounds(int screenWidth) {
#         return (posX < 0 || posX >= screenWidth);
#     }
# }
# 
# // Classe base para aeronaves
# abstract class Aircraft {
#     protected int health;
#     protected int speed;
#     protected int fireRate;
#     protected int maneuverability;
#     protected String symbol;
#     protected int posY;  // 0 = TOPO, 1 = MEIO, 2 = FUNDO
# 
#     public abstract int move();
#     public abstract int changeAltitude();
#     public abstract Projectile shoot(int posX, int direction);
# 
#     public void takeDamage(int damage) {
#         this.health -= damage;
#     }
# 
#     public boolean isAlive() {
#         return this.health > 0;
#     }
# }
# 
# // Aeronave customizada com movimenta√ß√£o vertical e tiros
# class CustomAircraft extends Aircraft {
#     private Random random = new Random();
#     private int fireCooldown = 0;
# 
#     public CustomAircraft(String symbol, int speed, int fireRate, int maneuverability) {
#         this.health = 100;
#         this.speed = speed;
#         this.fireRate = fireRate;
#         this.maneuverability = maneuverability;
#         this.symbol = symbol;
#         this.posY = 1;  // Come√ßa no meio
#     }
# 
#     public int move() {
#         return random.nextInt(speed + 1) - speed / 2;
#     }
# 
#     public int changeAltitude() {
#         int direction = random.nextInt(3) - 1;  // -1 = sobe, 0 = mant√©m, 1 = desce
#         posY = Math.max(0, Math.min(2, posY + direction));
#         return direction;
#     }
# 
#     public Projectile shoot(int posX, int direction) {
#         if (fireCooldown == 0) {
#             fireCooldown = fireRate;
#             return new Projectile(posX, posY, direction, (direction == 1) ? "->" : "<-");
#         }
#         fireCooldown--;
#         return null;
#     }
# }
# 
# // Simula√ß√£o do Combate
# public class AsciiCombat {
#     public static void battle(Aircraft p1, Aircraft p2) {
#         int p1PosX = 2;
#         int p2PosX = 47;
#         int screenWidth = 50;
# 
#         ArrayList<Projectile> projectiles = new ArrayList<>();
# 
#         while (p1.isAlive() && p2.isAlive()) {
#             System.out.println("\n=== NOVO TURNO ===");
# 
#             // Limpa o campo de batalha
#             String[][] battlefield = new String[3][screenWidth];
#             for (int row = 0; row < 3; row++) {
#                 for (int i = 0; i < screenWidth; i++) {
#                     battlefield[row][i] = " ";
#                 }
#             }
# 
#             // Movimenta√ß√£o das aeronaves
#             p1PosX += p1.move();
#             p2PosX += p2.move();
#             p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
#             p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));
# 
#             int p1AltChange = p1.changeAltitude();
#             int p2AltChange = p2.changeAltitude();
# 
#             // Posiciona as aeronaves
#             battlefield[p1.posY][p1PosX] = p1.symbol;
#             battlefield[p2.posY][p2PosX] = p2.symbol;
# 
#             // Disparos - Cada tiro viaja a cada turno
#             Projectile newP1Shot = p1.shoot(p1PosX, 1);
#             Projectile newP2Shot = p2.shoot(p2PosX, -1);
# 
#             if (newP1Shot != null) projectiles.add(newP1Shot);
#             if (newP2Shot != null) projectiles.add(newP2Shot);
# 
#             // Movimenta√ß√£o dos tiros
#             Iterator<Projectile> iterator = projectiles.iterator();
#             while (iterator.hasNext()) {
#                 Projectile p = iterator.next();
#                 p.move();
# 
#                 // Verifica se atingiu o oponente
#                 if ((p.direction == 1 && p.posX == p2PosX && p.posY == p2.posY) ||
#                     (p.direction == -1 && p.posX == p1PosX && p.posY == p1.posY)) {
#                     System.out.println("X Tiro acertou um inimigo!");
#                     if (p.direction == 1) p2.takeDamage(10);
#                     else p1.takeDamage(10);
#                     iterator.remove();
#                 } else if (p.isOutOfBounds(screenWidth)) {
#                     iterator.remove(); // Remove tiros que sa√≠ram da tela
#                 } else {
#                     battlefield[p.posY][p.posX] = p.symbol;
#                 }
#             }
# 
#             // Mostrar o campo de batalha
#             for (int row = 0; row < 3; row++) {
#                 for (int i = 0; i < screenWidth; i++) {
#                     System.out.print(battlefield[row][i]);
#                 }
#                 System.out.println();
#             }
# 
#             // Vida das aeronaves
#             System.out.println("Vida P1: " + p1.health + " | Vida P2: " + p2.health);
# 
#             // Pausa para simular anima√ß√£o
#             try { Thread.sleep(500); } catch (InterruptedException e) {}
#         }
# 
#         System.out.println("\n=== FIM DA BATALHA ===");
#         if (p1.isAlive()) {
#             System.out.println("Equipe 1 venceu!");
#         } else {
#             System.out.println("Equipe 2 venceu!");
#         }
#     }
# 
#     public static void main(String[] args) {
#         // Configura√ß√£o manual das aeronaves
#         Aircraft team1 = new CustomAircraft("‚ñ∂", 7, 2, 5);  // (S√≠mbolo, Velocidade, Taxa de Tiro, Manobrabilidade)
#         Aircraft team2 = new CustomAircraft("‚óÄ", 5, 3, 7);  // Configura√ß√£o personalizada
# 
#         battle(team1, team2);
#     }
# }
#

!javac AsciiCombat.java
!java AsciiCombat

!javac AsciiCombat.java
!java AsciiCombat

!pip install gradio

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int posY = 1;  // Linha inicial (0=Topo, 1=Meio, 2=Fundo)
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);

    public void takeDamage(int damage) {
        this.health -= damage;
    }

    public int getHealth() {
        return health;
    }

    public int getPositionY() {
        return posY;
    }

    public boolean isAlive() {
        return health > 0;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;  // 1 = direita, -1 = esquerda
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    # C√≥digo principal do jogo (BattleMain.java)
    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 47;
        int screenWidth = 50;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            // Campo de batalha
            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            // Movimenta√ß√£o das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            // Posi√ß√£o das aeronaves
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Disparos
            Projectile p1Shot = team1.shoot(p1PosX, 1);
            Projectile p2Shot = team2.shoot(p2PosX, -1);

            if (p1Shot != null) projectiles.add(p1Shot);
            if (p2Shot != null) projectiles.add(p2Shot);

            // Movimenta√ß√£o dos tiros
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                // Verificar se o tiro atingiu o oponente
                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {
                    System.out.println("üî• Tiro acertou um inimigo!");
                    if (p.direction == 1) team2.takeDamage(10);
                    else team1.takeDamage(10);
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            // Exibir o campo de batalha
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("Vida P1: " + team1.getHealth() + " | Vida P2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("\\nüèÜ Equipe 1 venceu!");
        } else {
            System.out.println("\\nüèÜ Equipe 2 venceu!");
        }
    }
}
"""

    # Salvar os arquivos das classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    # Salvar as aeronaves dos times
    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    # Salvar o c√≥digo principal (BattleMain)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar todas as classes em ordem correta
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        result = subprocess.run(
            ["java", "-cp", "combat_classes", "BattleMain"],
            capture_output=True, text=True
        )
        return result.stdout + result.stderr

    except Exception as e:
        return f"‚ö† Erro durante a execu√ß√£o: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate", lines=20)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida e simbolo"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int posY = 1;  // Linha inicial (0=Topo, 1=Meio, 2=Fundo)
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);

    public void takeDamage(int damage) {
        this.health -= damage;
    }

    public int getHealth() {
        return health;
    }

    public int getPositionY() {
        return posY;
    }

    public boolean isAlive() {
        return health > 0;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;  // 1 = direita, -1 = esquerda
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    # C√≥digo principal do jogo (BattleMain.java)
    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 47;
        int screenWidth = 50;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            // Campo de batalha
            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            // Movimenta√ß√£o das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            // Posi√ß√£o das aeronaves
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Disparos
            Projectile p1Shot = team1.shoot(p1PosX, 1);
            Projectile p2Shot = team2.shoot(p2PosX, -1);

            if (p1Shot != null) projectiles.add(p1Shot);
            if (p2Shot != null) projectiles.add(p2Shot);

            // Movimenta√ß√£o dos tiros
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                // Verificar se o tiro atingiu o oponente
                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {
                    System.out.println("üî• Tiro acertou um inimigo!");
                    if (p.direction == 1) team2.takeDamage(10);
                    else team1.takeDamage(10);
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            // Exibir o campo de batalha
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("Vida P1: " + team1.getHealth() + " | Vida P2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("\\nüèÜ Equipe 1 venceu!");
        } else {
            System.out.println("\\nüèÜ Equipe 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    # Salvar as aeronaves dos times
    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    # Salvar o c√≥digo principal (BattleMain)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar todas as classes em ordem correta
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha em tempo real
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # Capturar a sa√≠da em tempo real
        output = ""
        for line in process.stdout:
            output += line
            yield output  # Atualiza a interface em tempo real

        # Capturar erros, se houver
        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o: {error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida, velocidade e simbolo"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed = 1;  // Velocidade padr√£o
    protected int posY = 1;
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);

    public void takeDamage(int damage) {
        this.health -= damage;
    }

    public int getHealth() {
        return health;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSpeed() {
        return speed;
    }

    public boolean isAlive() {
        return health > 0;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 47;
        int screenWidth = 50;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            // Movimenta√ß√£o das aeronaves com base na velocidade
            p1PosX += team1.move() * team1.getSpeed();
            p2PosX += team2.move() * team2.getSpeed();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Disparos
            Projectile p1Shot = team1.shoot(p1PosX, 1);
            Projectile p2Shot = team2.shoot(p2PosX, -1);

            if (p1Shot != null) projectiles.add(p1Shot);
            if (p2Shot != null) projectiles.add(p2Shot);

            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {
                    System.out.println("üî• Tiro acertou um inimigo!");
                    if (p.direction == 1) team2.takeDamage(10);
                    else team1.takeDamage(10);
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar as classes
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in process.stdout:
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida, velocidade, manobrabilidade e simbolo"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed = 1;  // Velocidade padr√£o
    protected int maneuverability = 1;  // Chance de desvio (0 a 10)
    protected int posY = 1;
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);

    public void takeDamage(int damage) {
        this.health -= damage;
    }

    public int getHealth() {
        return health;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSpeed() {
        return speed;
    }

    public int getManeuverability() {
        return maneuverability;
    }

    public boolean isAlive() {
        return health > 0;
    }

    // Chance de desvio com base na manobrabilidade (0 a 10)
    public boolean dodge() {
        return Math.random() * 10 < maneuverability;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 47;
        int screenWidth = 50;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            // Movimenta√ß√£o das aeronaves com base na velocidade
            p1PosX += team1.move() * team1.getSpeed();
            p2PosX += team2.move() * team2.getSpeed();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Disparos
            Projectile p1Shot = team1.shoot(p1PosX, 1);
            Projectile p2Shot = team2.shoot(p2PosX, -1);

            if (p1Shot != null) projectiles.add(p1Shot);
            if (p2Shot != null) projectiles.add(p2Shot);

            // Movimenta√ß√£o dos tiros
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {

                    // Verificar chance de desvio
                    if (p.direction == 1 && team2.dodge()) {
                        System.out.println("üí® Time 2 desviou do tiro!");
                    } else if (p.direction == -1 && team1.dodge()) {
                        System.out.println("üí® Time 1 desviou do tiro!");
                    } else {
                        System.out.println("üî• Tiro acertou um inimigo!");
                        if (p.direction == 1) team2.takeDamage(10);
                        else team1.takeDamage(10);
                    }
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            // Exibir o campo de batalha
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar as classes
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in process.stdout:
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida, velocidade, manobrabilidade, dano do tiro normal e simbolo"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed = 1;
    protected int maneuverability = 1;
    protected int shotPower = 10;    // Dano por tiro normal
    protected int posY = 1;
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);

    public void takeDamage(int damage) {
        this.health -= damage;
    }

    public int getHealth() {
        return health;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSpeed() {
        return speed;
    }

    public int getManeuverability() {
        return maneuverability;
    }

    public int getShotPower() {
        return shotPower;
    }

    public boolean isAlive() {
        return health > 0;
    }

    public boolean dodge() {
        return Math.random() * 10 < maneuverability;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 47;
        int screenWidth = 50;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            // Movimenta√ß√£o das aeronaves com base na velocidade
            p1PosX += team1.move() * team1.getSpeed();
            p2PosX += team2.move() * team2.getSpeed();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Disparos normais
            Projectile p1Shot = team1.shoot(p1PosX, 1);
            Projectile p2Shot = team2.shoot(p2PosX, -1);

            if (p1Shot != null) projectiles.add(p1Shot);
            if (p2Shot != null) projectiles.add(p2Shot);

            // Movimenta√ß√£o dos tiros e verifica√ß√£o de acertos
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {

                    if (p.direction == 1) {
                        if (team2.dodge()) {
                            System.out.println("üí® Time 2 desviou do tiro!");
                        } else {
                            System.out.println("üî• Time 1 acertou Time 2! Dano: " + team1.getShotPower());
                            team2.takeDamage(team1.getShotPower());
                        }
                    } else {
                        if (team1.dodge()) {
                            System.out.println("üí® Time 1 desviou do tiro!");
                        } else {
                            System.out.println("üí• Time 2 acertou Time 1! Dano: " + team2.getShotPower());
                            team1.takeDamage(team2.getShotPower());
                        }
                    }
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            // Exibir o campo de batalha
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar as classes
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in process.stdout:
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida, velocidade, manobrabilidade, dano do tiro normal, missil especial (com recarga) e simbolo"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed = 2;
    protected int fireRate = 1;
    protected int maneuverability = 2;
    protected int shotPower = 10;
    protected int missilePower = 30;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public void takeDamage(int damage) {
        this.health -= damage;
    }

    public int getHealth() {
        return health;
    }

    public int getPositionY() {
        return posY;
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getFireRate() { return fireRate; }
    public int getShotPower() { return shotPower; }
    public int getMissilePower() { return missilePower; }

    public boolean dodge() {
        return Math.random() * 10 < maneuverability;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 47;
        int screenWidth = 50;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Disparos normais conforme taxa de tiro
            for (int i = 0; i < team1.getFireRate(); i++) {
                Projectile p1Shot = team1.shoot(p1PosX, 1);
                if (p1Shot != null) projectiles.add(p1Shot);
            }
            for (int i = 0; i < team2.getFireRate(); i++) {
                Projectile p2Shot = team2.shoot(p2PosX, -1);
                if (p2Shot != null) projectiles.add(p2Shot);
            }

            // M√≠sseis especiais (recarga de 3 turnos)
            Projectile p1Missile = team1.specialMissile(p1PosX, 1);
            if (p1Missile != null) projectiles.add(p1Missile);

            Projectile p2Missile = team2.specialMissile(p2PosX, -1);
            if (p2Missile != null) projectiles.add(p2Missile);

            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                // Verificar acertos
                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {

                    if (p.direction == 1) {
                        if (team2.dodge()) {
                            System.out.println("üí® Time 2 desviou!");
                        } else {
                            int dano = p.symbol.equals("=>") ? team1.getMissilePower() : team1.getShotPower();
                            System.out.println("üî• Time 1 acertou Time 2! Dano: " + dano);
                            team2.takeDamage(dano);
                        }
                    } else {
                        if (team1.dodge()) {
                            System.out.println("üí® Time 1 desviou!");
                        } else {
                            int dano = p.symbol.equals("<=") ? team2.getMissilePower() : team2.getShotPower();
                            System.out.println("üí• Time 2 acertou Time 1! Dano: " + dano);
                            team1.takeDamage(dano);
                        }
                    }
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar as classes
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        output = ""
        for line in process.stdout:
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida, velocidade, manobrabilidade, dano do tiro normal, missil especial (com recarga), defesa (=20, √© 20% de redu√ß√£o de dano) e simbolo"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed = 2;
    protected int fireRate = 1;
    protected int maneuverability = 2;
    protected int shotPower = 10;
    protected int missilePower = 30;
    protected int defense = 10;  // Percentual de redu√ß√£o de dano (ex.: 10%).
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public void takeDamage(int damage) {
        int reducedDamage = damage - (damage * defense / 100);  // Reduz o dano com base na defesa
        this.health -= reducedDamage;
    }

    public int getHealth() {
        return health;
    }

    public int getPositionY() {
        return posY;
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getFireRate() { return fireRate; }
    public int getShotPower() { return shotPower; }
    public int getMissilePower() { return missilePower; }
    public int getDefense() { return defense; }

    public boolean dodge() {
        return Math.random() * 10 < maneuverability;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 47;
        int screenWidth = 50;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Disparos normais conforme taxa de tiro
            for (int i = 0; i < team1.getFireRate(); i++) {
                Projectile p1Shot = team1.shoot(p1PosX, 1);
                if (p1Shot != null) projectiles.add(p1Shot);
            }
            for (int i = 0; i < team2.getFireRate(); i++) {
                Projectile p2Shot = team2.shoot(p2PosX, -1);
                if (p2Shot != null) projectiles.add(p2Shot);
            }

            // M√≠sseis especiais (recarga de 3 turnos)
            Projectile p1Missile = team1.specialMissile(p1PosX, 1);
            if (p1Missile != null) projectiles.add(p1Missile);

            Projectile p2Missile = team2.specialMissile(p2PosX, -1);
            if (p2Missile != null) projectiles.add(p2Missile);

            // Processar tiros
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {

                    if (p.direction == 1) {
                        if (team2.dodge()) {
                            System.out.println("üí® Time 2 desviou!");
                        } else {
                            int dano = p.symbol.equals("=>") ? team1.getMissilePower() : team1.getShotPower();
                            System.out.println("üî• Time 1 acertou Time 2! Dano: " + dano + " (Defesa: " + team2.getDefense() + "%)");
                            team2.takeDamage(dano);
                        }
                    } else {
                        if (team1.dodge()) {
                            System.out.println("üí® Time 1 desviou!");
                        } else {
                            int dano = p.symbol.equals("<=") ? team2.getMissilePower() : team2.getShotPower();
                            System.out.println("üí• Time 2 acertou Time 1! Dano: " + dano + " (Defesa: " + team1.getDefense() + "%)");
                            team1.takeDamage(dano);
                        }
                    }
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar as classes
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        output = ""
        for line in process.stdout:
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida, velocidade, manobrabilidade, dano do tiro normal, missil especial (com recarga), defesa (=20, √© 20% de redu√ß√£o de dano), furtividade e simbolo"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed = 2;
    protected int fireRate = 1;
    protected int maneuverability = 2;
    protected int shotPower = 10;
    protected int missilePower = 30;
    protected int defense = 10;
    protected int stealthChance = 20;  // Chance de furtividade em %
    protected boolean isStealth = false;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public void activateStealth() {
        this.isStealth = (Math.random() * 100) < stealthChance;
    }

    public boolean isStealthActive() {
        return isStealth;
    }

    public void takeDamage(int damage) {
        if (!isStealth) {
            int reducedDamage = damage - (damage * defense / 100);
            this.health -= reducedDamage;
        } else {
            System.out.println("üü£ Furtividade ativa! Nenhum dano recebido.");
        }
    }

    public int getHealth() { return health; }
    public int getPositionY() { return posY; }
    public boolean isAlive() { return health > 0; }
    public int getFireRate() { return fireRate; }
    public int getShotPower() { return shotPower; }
    public int getMissilePower() { return missilePower; }
    public int getDefense() { return defense; }
    public int getStealthChance() { return stealthChance; }

    public boolean dodge() {
        return Math.random() * 10 < maneuverability;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    String symbol;

    public Projectile(int posX, int posY, int direction, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 97;
        int screenWidth = 100;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            // Ativar furtividade para o turno atual
            team1.activateStealth();
            team2.activateStealth();

            // Campo de batalha
            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            battlefield[team1.getPositionY()][p1PosX] = team1.isStealthActive() ? "üü£" : team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.isStealthActive() ? "üü£" : team2.symbol;

            // Disparos normais conforme taxa de tiro
            for (int i = 0; i < team1.getFireRate(); i++) {
                Projectile p1Shot = team1.shoot(p1PosX, 1);
                if (p1Shot != null) projectiles.add(p1Shot);
            }

            for (int i = 0; i < team2.getFireRate(); i++) {
                Projectile p2Shot = team2.shoot(p2PosX, -1);
                if (p2Shot != null) projectiles.add(p2Shot);
            }

            // M√≠sseis especiais (recarga de 3 turnos)
            Projectile p1Missile = team1.specialMissile(p1PosX, 1);
            if (p1Missile != null) projectiles.add(p1Missile);

            Projectile p2Missile = team2.specialMissile(p2PosX, -1);
            if (p2Missile != null) projectiles.add(p2Missile);

            // Processar tiros
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {

                    if (p.direction == 1 && !team2.isStealthActive()) {
                        if (team2.dodge()) {
                            System.out.println("üí® Time 2 desviou!");
                        } else {
                            int dano = p.symbol.equals("=>") ? team1.getMissilePower() : team1.getShotPower();
                            System.out.println("üî• Time 1 acertou Time 2! Dano: " + dano);
                            team2.takeDamage(dano);
                        }
                    } else if (p.direction == -1 && !team1.isStealthActive()) {
                        if (team1.dodge()) {
                            System.out.println("üí® Time 1 desviou!");
                        } else {
                            int dano = p.symbol.equals("<=") ? team2.getMissilePower() : team2.getShotPower();
                            System.out.println("üí• Time 2 acertou Time 1! Dano: " + dano);
                            team1.takeDamage(dano);
                        }
                    } else {
                        System.out.println("üü£ Tiro falhou devido √† furtividade!");
                    }
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            // Exibir campo de batalha
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar as classes
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        output = ""
        for line in process.stdout:
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Funcionando com frame atualizando a cada rodada e com vida, velocidade, manobrabilidade, dano do tiro normal, missil especial (com recarga), defesa (=20, √© 20% de redu√ß√£o de dano), furtividade, tiro supersonico e simbolo

FUNCIONANDO PERFEITAMENTE!
"""

import gradio as gr
import os
import subprocess

# Criar pasta para as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos das classes
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed = 2;
    protected int fireRate = 1;
    protected int maneuverability = 2;
    protected int shotPower = 10;
    protected int supersonicPower = 15;  // Dano do tiro supers√¥nico
    protected int missilePower = 30;
    protected int defense = 10;
    protected int stealthChance = 20;
    protected boolean isStealth = false;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public void activateStealth() {
        this.isStealth = (Math.random() * 100) < stealthChance;
    }

    public boolean isStealthActive() {
        return isStealth;
    }

    public void takeDamage(int damage) {
        if (!isStealth) {
            int reducedDamage = damage - (damage * defense / 100);
            this.health -= reducedDamage;
        } else {
            System.out.println("üü£ Furtividade ativa! Nenhum dano recebido.");
        }
    }

    public int getHealth() { return health; }
    public int getPositionY() { return posY; }
    public boolean isAlive() { return health > 0; }
    public int getFireRate() { return fireRate; }
    public int getShotPower() { return shotPower; }
    public int getSupersonicPower() { return supersonicPower; }
    public int getMissilePower() { return missilePower; }
    public int getDefense() { return defense; }
    public int getStealthChance() { return stealthChance; }

    public boolean dodge() {
        return Math.random() * 10 < maneuverability;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.Random;
import java.util.ArrayList;
import java.util.Iterator;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        int p1PosX = 2;
        int p2PosX = 98;
        int screenWidth = 100;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");

            // Ativar furtividade para o turno atual
            team1.activateStealth();
            team2.activateStealth();

            // Campo de batalha
            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            team1.changeAltitude();
            team2.changeAltitude();

            battlefield[team1.getPositionY()][p1PosX] = team1.isStealthActive() ? "üü£" : team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.isStealthActive() ? "üü£" : team2.symbol;

            // Disparos normais conforme taxa de tiro
            for (int i = 0; i < team1.getFireRate(); i++) {
                Projectile p1Shot = team1.shoot(p1PosX, 1);
                if (p1Shot != null) projectiles.add(p1Shot);
            }

            for (int i = 0; i < team2.getFireRate(); i++) {
                Projectile p2Shot = team2.shoot(p2PosX, -1);
                if (p2Shot != null) projectiles.add(p2Shot);
            }

            // Tiros Supers√¥nicos
            Projectile p1Supersonic = team1.shootSupersonic(p1PosX, 1);
            if (p1Supersonic != null) projectiles.add(p1Supersonic);

            Projectile p2Supersonic = team2.shootSupersonic(p2PosX, -1);
            if (p2Supersonic != null) projectiles.add(p2Supersonic);

            // M√≠sseis especiais (recarga de 3 turnos)
            Projectile p1Missile = team1.specialMissile(p1PosX, 1);
            if (p1Missile != null) projectiles.add(p1Missile);

            Projectile p2Missile = team2.specialMissile(p2PosX, -1);
            if (p2Missile != null) projectiles.add(p2Missile);

            // Processar tiros
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                if ((p.direction == 1 && p.posX == p2PosX && p.posY == team2.getPositionY()) ||
                    (p.direction == -1 && p.posX == p1PosX && p.posY == team1.getPositionY())) {

                    if (p.direction == 1 && !team2.isStealthActive()) {
                        if (team2.dodge()) {
                            System.out.println("üí® Time 2 desviou!");
                        } else {
                            int dano = p.symbol.equals(">>") ? team1.getSupersonicPower() : team1.getShotPower();
                            System.out.println("üî• Time 1 acertou Time 2! Dano: " + dano);
                            team2.takeDamage(dano);
                        }
                    } else if (p.direction == -1 && !team1.isStealthActive()) {
                        if (team1.dodge()) {
                            System.out.println("üí® Time 1 desviou!");
                        } else {
                            int dano = p.symbol.equals(">>") ? team2.getSupersonicPower() : team2.getShotPower();
                            System.out.println("üí• Time 2 acertou Time 1! Dano: " + dano);
                            team1.takeDamage(dano);
                        }
                    } else {
                        System.out.println("üü£ Tiro falhou devido √† furtividade!");
                    }
                    iterator.remove();
                } else if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                } else {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            // Exibir campo de batalha
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());

            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
    }
}
"""

    # Salvar as classes base
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)

    with open(projectile_path, "w") as f:
        f.write(projectile_code)

    with open(class1_path, "w") as f1:
        f1.write(code1)

    with open(class2_path, "w") as f2:
        f2.write(code2)

    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar as classes
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(
                ["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file],
                capture_output=True, text=True
            )
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o de {java_file}:\n{compile_result.stderr}"

        # Executar a batalha
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        output = ""
        for line in process.stdout:
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio
with gr.Blocks() as app:
    gr.Markdown("# ‚Øêüõ¶üõß Arena de Combate - Time 1 vs Time 2")
    gr.Markdown("Cole o c√≥digo Java das aeronaves para cada time e clique em 'Combate!' para assistir √† batalha!")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo do Time 1 (Classe Team1Aircraft.java)", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo do Time 2 (Classe Team2Aircraft.java)", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate em Tempo Real", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

"""Fant√°stico esse"""

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, String symbol) {
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.symbol = symbol;

        validateAttributes();
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower + missilePower + defense + stealthChance;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos!");
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    battle_main_code = """
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {
    public static void main(String[] args) {
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();
        Random random = new Random();

        int p1PosX = 2;
        int p2PosX = 98;
        int screenWidth = 100;
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[3][screenWidth];
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    battlefield[row][i] = " ";
                }
            }

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();

            // Atirar
            if (random.nextInt(10) < team1.fireRate) {
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {
                    shot = team1.specialMissile(p1PosX, 1);
                } else if (shotType < 40) {
                    shot = team1.shootSupersonic(p1PosX, 1);
                } else {
                    shot = team1.shoot(p1PosX, 1);
                }
                if (shot != null) {
                    projectiles.add(shot);
                }
            }

            if (random.nextInt(10) < team2.fireRate) {
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {
                    shot = team2.specialMissile(p2PosX, -1);
                } else if (shotType < 40) {
                    shot = team2.shootSupersonic(p2PosX, -1);
                } else {
                    shot = team2.shoot(p2PosX, -1);
                }
                if (shot != null) {
                    projectiles.add(shot);
                }
            }

            // Posicionar aeronaves no campo de batalha
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {
                    int damage = 0;
                    if (p.symbol.equals("<=")) {
                        damage = team2.missilePower;
                    } else if (p.symbol.equals("<<")) {
                        damage = team2.supersonicPower;
                    } else {
                        damage = team2.shotPower;
                    }

                    if (random.nextInt(100) >= team1.stealthChance) {
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    } else {
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                    }
                    iterator.remove();
                    continue;
                }

                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {
                    int damage = 0;
                    if (p.symbol.equals("=>")) {
                        damage = team1.missilePower;
                    } else if (p.symbol.equals(">>")) {
                        damage = team1.supersonicPower;
                    } else {
                        damage = team1.shotPower;
                    }

                    if (random.nextInt(100) >= team2.stealthChance) {
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    } else {
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                    }
                    iterator.remove();
                    continue;
                }

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {
                    iterator.remove();
                    continue;
                }

                // Mostrar proj√©teis no campo de batalha
                if (p.posX >= 0 && p.posX < screenWidth) {
                    battlefield[p.posY][p.posX] = p.symbol;
                }
            }

            // Mostrar campo de batalha
            for (int row = 0; row < 3; row++) {
                for (int i = 0; i < screenWidth; i++) {
                    System.out.print(battlefield[row][i]);
                }
                System.out.println();
            }

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                System.err.println("Erro na pausa: " + e.getMessage());
            }
        }

        if (team1.isAlive()) {
            System.out.println("üèÜ Time 1 venceu!");
        } else {
            System.out.println("üèÜ Time 2 venceu!");
        }
        System.out.flush();
    }
}
"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in iter(process.stdout.readline, ""):
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio Ajustada
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate", lines=30)

    btn.click(run_battle, inputs=[team1_code, team2_code], outputs=output)

app.launch()

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, String symbol) {
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.symbol = symbol;

        validateAttributes();
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower + missilePower + defense + stealthChance;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos!");
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    # C√≥digo do BattleMain com par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();
        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {{
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 40) {{
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    shot = team1.shoot(p1PosX, 1);
                }}
                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {{
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 40) {{
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    shot = team2.shoot(p2PosX, -1);
                }}
                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;
                    if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                    }}
                    iterator.remove();
                    continue;
                }}

                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;
                    if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    battlefield[p.posY][p.posX] = p.symbol;
                }}
            }}

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}
"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in iter(process.stdout.readline, ""):
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio Ajustada com Configura√ß√µes
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos):
            yield output

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate", lines=30)

    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos],
              outputs=output)

app.launch()

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves
TEAM1_TEMPLATE = '''import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            30, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+30+15+5 = 100
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(2, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }
}'''

TEAM2_TEMPLATE = '''import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            30, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+30+15+5 = 100
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(2, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }
}'''

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, String symbol) {
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.symbol = symbol;

        validateAttributes();
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower + missilePower + defense + stealthChance;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos!");
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    # C√≥digo do BattleMain com par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();
        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {{
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 40) {{
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    shot = team1.shoot(p1PosX, 1);
                }}
                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {{
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 40) {{
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    shot = team2.shoot(p2PosX, -1);
                }}
                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;
                    if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                    }}
                    iterator.remove();
                    continue;
                }}

                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;
                    if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    battlefield[p.posY][p.posX] = p.symbol;
                }}
            }}

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}
"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in iter(process.stdout.readline, ""):
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos):
            yield output

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate", lines=30)

    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - Consulte o material de apoio para estrat√©gias avan√ßadas.

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves com altura din√¢mica
TEAM1_TEMPLATE = '''import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            30, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+30+15+5 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }
}'''

TEAM2_TEMPLATE = '''import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            30, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+30+15+5 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }
}'''

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # C√≥digo base das classes Aircraft e Projectile
    aircraft_code = """
public abstract class Aircraft {
    protected int health = 100;
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, String symbol) {
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.symbol = symbol;

        validateAttributes();
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower + missilePower + defense + stealthChance;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos!");
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }
}
"""

    projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }
}
"""

    # C√≥digo do BattleMain com par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        // Definir a altura do campo como propriedade do sistema
        System.setProperty("battlefield.height", "{battlefield_height}");

        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();
        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        // Inicializar as altitudes das naves em uma posi√ß√£o m√©dia do campo
        team1.posY = battlefieldHeight / 2;
        team2.posY = battlefieldHeight / 2;

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {{
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 40) {{
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    shot = team1.shoot(p1PosX, 1);
                }}
                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);
                if (shotType < 15) {{
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 40) {{
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    shot = team2.shoot(p2PosX, -1);
                }}
                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;
                    if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                    }}
                    iterator.remove();
                    continue;
                }}

                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;
                    if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    battlefield[p.posY][p.posX] = p.symbol;
                }}
            }}

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}
"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in iter(process.stdout.readline, ""):
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos):
            yield output

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate", lines=30)

    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - Consulte o material de apoio para estrat√©gias avan√ßadas.
    - Use toda a altura do campo (configure nas op√ß√µes) para estrat√©gias mais interessantes!

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves com altura din√¢mica e novos atributos
TEAM1_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áâ");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "-]=>");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

TEAM2_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áá");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "<[=-");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

# C√≥digo base das classes Aircraft e Projectile atualizados com os novos recursos
aircraft_code = """
import java.util.ArrayList;

public abstract class Aircraft {
    protected int health = 200;
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int radar;
    protected int doubleShot;
    protected int doubleShotPower;
    protected int nuclearPower;
    protected int secondShotAltitude = -1;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, int radar, int doubleShot,
                    int nuclearPower, String symbol) {
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.radar = radar;
        this.doubleShot = doubleShot;
        this.doubleShotPower = doubleShot;
        this.nuclearPower = nuclearPower;
        this.symbol = symbol;

        validateAttributes();
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower +
                   missilePower + defense + stealthChance + radar + doubleShot + nuclearPower;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos! Total: " + total);
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);
    public abstract Projectile doubleShot(int posX, int direction);
    public abstract Projectile nuclearMissile(int posX, int direction);
    public abstract void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSecondShotAltitude() {
        int alt = secondShotAltitude;
        secondShotAltitude = -1; // Reset ap√≥s uso
        return alt;
    }
}
"""

projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;
    int power = 0;  // Poder do proj√©til, usado para dano personalizado

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public Projectile(int posX, int posY, int direction, int speed, String symbol, int power) {
        this(posX, posY, direction, speed, symbol);
        this.power = power;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }

    public int getPower() {
        return power;
    }
}
"""

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # Gerar o c√≥digo do BattleMain com os par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        // Definir a altura do campo como propriedade do sistema
        System.setProperty("battlefield.height", "{battlefield_height}");

        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();
        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        // Inicializar as altitudes das naves em uma posi√ß√£o m√©dia do campo
        team1.posY = battlefieldHeight / 2;
        team2.posY = battlefieldHeight / 2;

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Radar scan para detectar proj√©teis
            team1.radarScan(projectiles, p2PosX, team2.getPositionY());
            team2.radarScan(projectiles, p1PosX, team1.getPositionY());

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar para Time 1
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team1.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team1.nuclearMissile(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 1 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team1.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team1.doubleShot(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚û°Ô∏è Time 1 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team1.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p1PosX, secAlt, 1, 1, "->", team1.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    // Tiro normal
                    shot = team1.shoot(p1PosX, 1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Atirar para Time 2
            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team2.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team2.nuclearMissile(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 2 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team2.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team2.doubleShot(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚¨ÖÔ∏è Time 2 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team2.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p2PosX, secAlt, -1, 1, "<-", team2.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    // Tiro normal
                    shot = team2.shoot(p2PosX, -1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes com Time 1
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("<[=-")) {{ // M√≠ssil nuclear do Time 2
                        damage = team2.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 2 atingiu o Time 1!");
                    }} else if (p.symbol.contains("‚áá")) {{ // Tiro duplo do Time 2
                        damage = team2.doubleShotPower;
                    }} else if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                        if (team1.radar > 0) {{
                            System.out.println("üì° Radar do Time 1 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Verificar colis√µes com Time 2
                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("-]=>")) {{ // M√≠ssil nuclear do Time 1
                        damage = team1.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 1 atingiu o Time 2!");
                    }} else if (p.symbol.contains("‚áâ")) {{ // Tiro duplo do Time 1
                        damage = team1.doubleShotPower;
                    }} else if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                        if (team2.radar > 0) {{
                            System.out.println("üì° Radar do Time 2 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    battlefield[p.posY][p.posX] = p.symbol;
                }}
            }}

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}
"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in iter(process.stdout.readline, ""):
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos):
            yield output

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate", lines=30)

    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - Consulte o material de apoio para estrat√©gias avan√ßadas.
    - Use toda a altura do campo (configure nas op√ß√µes) para estrat√©gias mais interessantes!

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

"""VERSAO PRETO E BRANCO, FUNCIONANDO PERFEITAMENTE!"""

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves com altura din√¢mica e novos atributos
TEAM1_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áâ");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "-]=>");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

TEAM2_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áá");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "<[=-");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

# C√≥digo base das classes Aircraft e Projectile atualizados com os novos recursos
aircraft_code = """
import java.util.ArrayList;

public abstract class Aircraft {
    protected int health;  // Agora definido externamente
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int radar;
    protected int doubleShot;
    protected int doubleShotPower;
    protected int nuclearPower;
    protected int secondShotAltitude = -1;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, int radar, int doubleShot,
                    int nuclearPower, String symbol) {
        this.health = 100;  // Valor padr√£o que ser√° substitu√≠do
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.radar = radar;
        this.doubleShot = doubleShot;
        this.doubleShotPower = doubleShot;
        this.nuclearPower = nuclearPower;
        this.symbol = symbol;

        validateAttributes();
    }

    public void setInitialHealth(int health) {
        this.health = health;
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower +
                   missilePower + defense + stealthChance + radar + doubleShot + nuclearPower;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos! Total: " + total);
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);
    public abstract Projectile doubleShot(int posX, int direction);
    public abstract Projectile nuclearMissile(int posX, int direction);
    public abstract void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSecondShotAltitude() {
        int alt = secondShotAltitude;
        secondShotAltitude = -1; // Reset ap√≥s uso
        return alt;
    }
}
"""

projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;
    int power = 0;  // Poder do proj√©til, usado para dano personalizado

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public Projectile(int posX, int posY, int direction, int speed, String symbol, int power) {
        this(posX, posY, direction, speed, symbol);
        this.power = power;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }

    public int getPower() {
        return power;
    }
}
"""

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos, team1_health, team2_health):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # Gerar o c√≥digo do BattleMain com os par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        // Definir a altura do campo como propriedade do sistema
        System.setProperty("battlefield.height", "{battlefield_height}");

        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        // Definir a vida inicial de cada aeronave
        team1.setInitialHealth({team1_health});
        team2.setInitialHealth({team2_health});

        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        // Inicializar as altitudes das naves em uma posi√ß√£o m√©dia do campo
        team1.posY = battlefieldHeight / 2;
        team2.posY = battlefieldHeight / 2;

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Radar scan para detectar proj√©teis
            team1.radarScan(projectiles, p2PosX, team2.getPositionY());
            team2.radarScan(projectiles, p1PosX, team1.getPositionY());

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar para Time 1
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team1.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team1.nuclearMissile(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 1 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team1.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team1.doubleShot(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚û°Ô∏è Time 1 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team1.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p1PosX, secAlt, 1, 1, "->", team1.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    // Tiro normal
                    shot = team1.shoot(p1PosX, 1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Atirar para Time 2
            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team2.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team2.nuclearMissile(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 2 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team2.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team2.doubleShot(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚¨ÖÔ∏è Time 2 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team2.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p2PosX, secAlt, -1, 1, "<-", team2.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    // Tiro normal
                    shot = team2.shoot(p2PosX, -1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha
            battlefield[team1.getPositionY()][p1PosX] = team1.symbol;
            battlefield[team2.getPositionY()][p2PosX] = team2.symbol;

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes com Time 1
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("<[=-")) {{ // M√≠ssil nuclear do Time 2
                        damage = team2.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 2 atingiu o Time 1!");
                    }} else if (p.symbol.contains("‚áá")) {{ // Tiro duplo do Time 2
                        damage = team2.doubleShotPower;
                    }} else if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                        if (team1.radar > 0) {{
                            System.out.println("üì° Radar do Time 1 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Verificar colis√µes com Time 2
                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("-]=>")) {{ // M√≠ssil nuclear do Time 1
                        damage = team1.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 1 atingiu o Time 2!");
                    }} else if (p.symbol.contains("‚áâ")) {{ // Tiro duplo do Time 1
                        damage = team1.doubleShotPower;
                    }} else if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                        if (team2.radar > 0) {{
                            System.out.println("üì° Radar do Time 2 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    battlefield[p.posY][p.posX] = p.symbol;
                }}
            }}

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar os arquivos Java
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        # Executar a simula√ß√£o
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        output = ""
        for line in iter(process.stdout.readline, ""):
            output += line
            yield output

        _, error = process.communicate()
        if error:
            yield f"\n‚ùå Erro durante a execu√ß√£o:\n{error}"

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha

    **NOVIDADES**: Agora suas aeronaves podem ter radar para detectar proj√©teis, tiro duplo para atacar em duas altitudes diferentes e at√© m√≠sseis nucleares para dano massivo!
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # Adicionando configura√ß√µes de vida
        with gr.Row():
            team1_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 1", info="Define a vida inicial da aeronave do Time 1")
            team2_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 2", info="Define a vida inicial da aeronave do Time 2")

        # Bot√£o para equalizar as vidas (opcional)
        def equalize_health(health_value):
            return health_value, health_value

        equalize_btn = gr.Button("üîÑ Igualar Vidas")
        equalize_btn.click(fn=equalize_health, inputs=team1_health, outputs=[team1_health, team2_health])

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos, t1_health, t2_health):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos, t1_health, t2_health):
            yield output

    btn = gr.Button("üî• Combate!")
    output = gr.Textbox(label="Resultado do Combate", lines=30)

    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria com os novos par√¢metros de vida
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos,
                     team1_health, team2_health],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - O radar permite detectar proj√©teis inimigos e realizar manobras evasivas autom√°ticas.
    - O tiro duplo ataca em duas altitudes ao mesmo tempo, aumentando suas chances de acerto.
    - O m√≠ssil nuclear causa dano massivo, mas tem um longo cooldown de 5 turnos.
    - Use toda a altura do campo (configure nas op√ß√µes) para estrat√©gias mais interessantes!
    - Agora voc√™ pode ajustar a vida inicial das aeronaves para batalhas mais longas ou equilibrar times desiguais!

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

"""VERSAO COLORIDA, FUNCIONANDO, MAS MELHORANDO A FLUIDEZ"""

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves com altura din√¢mica e novos atributos
TEAM1_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áâ");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "-]=>");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

TEAM2_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áá");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "<[=-");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

# C√≥digo base das classes Aircraft e Projectile atualizados com os novos recursos
aircraft_code = """
import java.util.ArrayList;

public abstract class Aircraft {
    protected int health;  // Agora definido externamente
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int radar;
    protected int doubleShot;
    protected int doubleShotPower;
    protected int nuclearPower;
    protected int secondShotAltitude = -1;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, int radar, int doubleShot,
                    int nuclearPower, String symbol) {
        this.health = 100;  // Valor padr√£o que ser√° substitu√≠do
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.radar = radar;
        this.doubleShot = doubleShot;
        this.doubleShotPower = doubleShot;
        this.nuclearPower = nuclearPower;
        this.symbol = symbol;

        validateAttributes();
    }

    public void setInitialHealth(int health) {
        this.health = health;
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower +
                   missilePower + defense + stealthChance + radar + doubleShot + nuclearPower;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos! Total: " + total);
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);
    public abstract Projectile doubleShot(int posX, int direction);
    public abstract Projectile nuclearMissile(int posX, int direction);
    public abstract void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSecondShotAltitude() {
        int alt = secondShotAltitude;
        secondShotAltitude = -1; // Reset ap√≥s uso
        return alt;
    }
}
"""

projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;
    int power = 0;  // Poder do proj√©til, usado para dano personalizado

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public Projectile(int posX, int posY, int direction, int speed, String symbol, int power) {
        this(posX, posY, direction, speed, symbol);
        this.power = power;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }

    public int getPower() {
        return power;
    }
}
"""
def format_battle_text(output):
    # Processar as cores ANSI para HTML
    output = output.replace("\033[31m", "<span style='color:red;'>")   # Time 2 (Vermelho)
    output = output.replace("\033[34m", "<span style='color:blue;'>")  # Time 1 (Azul)
    output = output.replace("\033[32m", "<span style='color:green;'>") # Outros elementos
    output = output.replace("\033[0m", "</span>")  # Reset de cor

    # Adicionar script de inicializa√ß√£o para scrollar diretamente
    scroll_script = """
    <script>
    (function() {
        const container = document.getElementById('battle-container');
        if (container) {
            // Definir scroll para o final e tamb√©m adicionar um event listener para manter o scroll no fim
            container.scrollTop = container.scrollHeight;

            // Observar mudan√ßas no container
            const observer = new MutationObserver(function() {
                // Verificar se o usu√°rio est√° vendo o final
                const isScrolledToBottom = container.scrollHeight - container.clientHeight <= container.scrollTop + 50;

                // Se o usu√°rio estiver olhando o final, manter o scroll l√°
                if (isScrolledToBottom) {
                    container.scrollTop = container.scrollHeight;
                }
            });

            observer.observe(container, { childList: true, subtree: true });
        }
    })();
    </script>
    """

    # Retornar HTML completo com container e script
    return f"""
    <div id="battle-container" style="height:400px; overflow:auto; border:1px solid #ccc; padding:10px;
                                     font-family:monospace; white-space:pre; background-color:#f8f8f8;
                                     display:block !important; visibility:visible !important;">
        {output}
    </div>
    {scroll_script}
    """

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos, team1_health, team2_health):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # Gerar o c√≥digo do BattleMain com os par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        // Definir a altura do campo como propriedade do sistema
        System.setProperty("battlefield.height", "{battlefield_height}");

        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        // Definir a vida inicial de cada aeronave
        team1.setInitialHealth({team1_health});
        team2.setInitialHealth({team2_health});

        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        // Inicializar as altitudes das naves em uma posi√ß√£o m√©dia do campo
        team1.posY = battlefieldHeight / 2;
        team2.posY = battlefieldHeight / 2;

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Radar scan para detectar proj√©teis
            team1.radarScan(projectiles, p2PosX, team2.getPositionY());
            team2.radarScan(projectiles, p1PosX, team1.getPositionY());

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar para Time 1
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team1.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team1.nuclearMissile(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 1 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team1.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team1.doubleShot(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚û°Ô∏è Time 1 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team1.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p1PosX, secAlt, 1, 1, "->", team1.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    // Tiro normal
                    shot = team1.shoot(p1PosX, 1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Atirar para Time 2
            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team2.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team2.nuclearMissile(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 2 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team2.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team2.doubleShot(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚¨ÖÔ∏è Time 2 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team2.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p2PosX, secAlt, -1, 1, "<-", team2.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    // Tiro normal
                    shot = team2.shoot(p2PosX, -1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha com cores
            battlefield[team1.getPositionY()][p1PosX] = "\u001B[34m" + team1.symbol + "\u001B[0m";  // Azul para Time 1
            battlefield[team2.getPositionY()][p2PosX] = "\u001B[31m" + team2.symbol + "\u001B[0m";  // Vermelho para Time 2

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes com Time 1
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("<[=-")) {{ // M√≠ssil nuclear do Time 2
                        damage = team2.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 2 atingiu o Time 1!");
                    }} else if (p.symbol.contains("‚áá")) {{ // Tiro duplo do Time 2
                        damage = team2.doubleShotPower;
                    }} else if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                        if (team1.radar > 0) {{
                            System.out.println("üì° Radar do Time 1 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Verificar colis√µes com Time 2
                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("-]=>")) {{ // M√≠ssil nuclear do Time 1
                        damage = team1.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 1 atingiu o Time 2!");
                    }} else if (p.symbol.contains("‚áâ")) {{ // Tiro duplo do Time 1
                        damage = team1.doubleShotPower;
                    }} else if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                        if (team2.radar > 0) {{
                            System.out.println("üì° Radar do Time 2 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha com cores
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    // Adicionar cores aos proj√©teis baseado na dire√ß√£o
                    if (p.direction > 0) {{
                        battlefield[p.posY][p.posX] = "\u001B[34m" + p.symbol + "\u001B[0m";  // Azul para Time 1
                    }} else {{
                        battlefield[p.posY][p.posX] = "\u001B[31m" + p.symbol + "\u001B[0m";  // Vermelho para Time 2
                    }}
                }}
            }}  // Fechamento do while

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # [c√≥digo para compilar]

        # Executar a simula√ß√£o
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        # Usar um buffer circular para armazenar apenas os turnos mais recentes
        from collections import deque
        MAX_TURNOS = 5  # Mostrar apenas os 5 turnos mais recentes durante a simula√ß√£o
        turnos_recentes = deque(maxlen=MAX_TURNOS)

        turno_atual = ""
        saida_completa = ""

        # Flag para indicar se estamos coletando um turno inteiro
        coletando_turno = False

        for line in iter(process.stdout.readline, ""):
            saida_completa += line

            if "=== NOVO TURNO ===" in line:
                # Finalizar turno anterior e adicion√°-lo √† fila circular
                if turno_atual:
                    turnos_recentes.append(turno_atual)

                # Iniciar novo turno
                turno_atual = line
                coletando_turno = True
            elif coletando_turno:
                # Continuar acumulando linhas no turno atual
                turno_atual += line

            # Mostrar apenas os turnos mais recentes para melhor fluidez
            saida_atual = "".join(list(turnos_recentes)) + turno_atual
            yield format_battle_text(saida_atual)

        # Adicionar √∫ltimo turno √† fila (se existir)
        if turno_atual:
            turnos_recentes.append(turno_atual)

        # No final, mostrar toda a simula√ß√£o
        yield format_battle_text(saida_completa)

        # [resto do c√≥digo para erros]
    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha

    **NOVIDADES**: Agora suas aeronaves podem ter radar para detectar proj√©teis, tiro duplo para atacar em duas altitudes diferentes e at√© m√≠sseis nucleares para dano massivo!
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # Adicionando configura√ß√µes de vida
        with gr.Row():
            team1_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 1", info="Define a vida inicial da aeronave do Time 1")
            team2_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 2", info="Define a vida inicial da aeronave do Time 2")

        # Bot√£o para equalizar as vidas (opcional)
        def equalize_health(health_value):
            return health_value, health_value

        equalize_btn = gr.Button("üîÑ Igualar Vidas")
        equalize_btn.click(fn=equalize_health, inputs=team1_health, outputs=[team1_health, team2_health])

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos, t1_health, t2_health):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos, t1_health, t2_health):
            yield output

    btn = gr.Button("üî• Combate!")
    #output = gr.Textbox(label="Resultado do Combate", lines=30)
    # Configurar o componente HTML com CSS adicional para visibilidade imediata
    css = """
   <style>
   #battle-result .prose {
    padding: 0 !important;
    margin: 0 !important;
    display: block !important;
    visibility: visible !important;
    }
    </style>
    """

    output = gr.HTML(label="Resultado do Combate", elem_id="battle-result", value=css)
    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria com os novos par√¢metros de vida
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos,
                     team1_health, team2_health],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - O radar permite detectar proj√©teis inimigos e realizar manobras evasivas autom√°ticas.
    - O tiro duplo ataca em duas altitudes ao mesmo tempo, aumentando suas chances de acerto.
    - O m√≠ssil nuclear causa dano massivo, mas tem um longo cooldown de 5 turnos.
    - Use toda a altura do campo (configure nas op√ß√µes) para estrat√©gias mais interessantes!
    - Agora voc√™ pode ajustar a vida inicial das aeronaves para batalhas mais longas ou equilibrar times desiguais!

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

"""COm cor, melhorando...As duas versoes d cima sao as perfeitas"""

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves com altura din√¢mica e novos atributos
TEAM1_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áâ");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "-]=>");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

TEAM2_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áá");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "<[=-");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

# C√≥digo base das classes Aircraft e Projectile atualizados com os novos recursos
aircraft_code = """
import java.util.ArrayList;

public abstract class Aircraft {
    protected int health;  // Agora definido externamente
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int radar;
    protected int doubleShot;
    protected int doubleShotPower;
    protected int nuclearPower;
    protected int secondShotAltitude = -1;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, int radar, int doubleShot,
                    int nuclearPower, String symbol) {
        this.health = 100;  // Valor padr√£o que ser√° substitu√≠do
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.radar = radar;
        this.doubleShot = doubleShot;
        this.doubleShotPower = doubleShot;
        this.nuclearPower = nuclearPower;
        this.symbol = symbol;

        validateAttributes();
    }

    public void setInitialHealth(int health) {
        this.health = health;
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower +
                   missilePower + defense + stealthChance + radar + doubleShot + nuclearPower;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos! Total: " + total);
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);
    public abstract Projectile doubleShot(int posX, int direction);
    public abstract Projectile nuclearMissile(int posX, int direction);
    public abstract void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSecondShotAltitude() {
        int alt = secondShotAltitude;
        secondShotAltitude = -1; // Reset ap√≥s uso
        return alt;
    }
}
"""

projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;
    int power = 0;  // Poder do proj√©til, usado para dano personalizado

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public Projectile(int posX, int posY, int direction, int speed, String symbol, int power) {
        this(posX, posY, direction, speed, symbol);
        this.power = power;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }

    public int getPower() {
        return power;
    }
}
"""
def format_battle_text(output):
    # Processar as cores ANSI para HTML
    output = output.replace("\033[31m", "<span style='color:red;'>")   # Time 2 (Vermelho)
    output = output.replace("\033[34m", "<span style='color:blue;'>")  # Time 1 (Azul)
    output = output.replace("\033[32m", "<span style='color:green;'>") # Outros elementos
    output = output.replace("\033[0m", "</span>")  # Reset de cor

    # Script de scroll muito mais agressivo para garantir que acompanhe os novos turnos
    scroll_script = """
    <script>
    (function() {
        // Fun√ß√£o robusta de scroll que vai para o final
        function forceScroll() {
            const container = document.getElementById('battle-container');
            if (container) {
                // For√ßar scroll para o final de qualquer jeito
                container.scrollTop = 999999;

                // Garantir que o pr√≥ximo render tamb√©m mantenha o scroll
                setTimeout(() => { container.scrollTop = 999999; }, 10);
                setTimeout(() => { container.scrollTop = 999999; }, 50);
            }
        }

        // Roda imediatamente e tamb√©m com curto atraso
        forceScroll();

        // Tamb√©m configura um intervalo para constantly verificar e ajustar o scroll
        // Isto vai garantir que mesmo com atualiza√ß√µes r√°pidas, o scroll acompanhe
        const scrollInterval = setInterval(forceScroll, 100);

        // Para o intervalo ap√≥s 30 segundos para n√£o consumir recursos indefinidamente
        setTimeout(() => { clearInterval(scrollInterval); }, 30000);
    })();
    </script>
    """

    # Para o final da simula√ß√£o, vamos usar um scroll ainda mais forte
    if "venceu" in output:
        scroll_script = """
        <script>
        (function() {
            function finalScroll() {
                const container = document.getElementById('battle-container');
                if (container) {
                    container.scrollTop = container.scrollHeight * 2;
                }
            }

            // Roda m√∫ltiplas vezes com delays crescentes para garantir que pegue o final
            finalScroll();
            for (let i = 1; i <= 10; i++) {
                setTimeout(finalScroll, i * 200);
            }
        })();
        </script>
        """

    # Reduzir a quantidade de conte√∫do para melhorar performance
    # Divide em turnos e pega s√≥ os √∫ltimos para melhor desempenho
    turnos = output.split("=== NOVO TURNO ===")
    if len(turnos) > 10 and "venceu" not in output:  # Se tiver muitos turnos e n√£o for o final
        output = "=== NOVO TURNO ===".join(turnos.slice(-8))  # Mostra s√≥ os √∫ltimos 8 turnos

    return f"""
    <div id="battle-container" style="height:500px; overflow:auto; border:1px solid #ccc; padding:10px;
                                     font-family:monospace; white-space:pre; background-color:#f8f8f8;">
        {output}
    </div>
    {scroll_script}
    """

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos, team1_health, team2_health):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # Gerar o c√≥digo do BattleMain com os par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        // Definir a altura do campo como propriedade do sistema
        System.setProperty("battlefield.height", "{battlefield_height}");

        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        // Definir a vida inicial de cada aeronave
        team1.setInitialHealth({team1_health});
        team2.setInitialHealth({team2_health});

        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        // Inicializar as altitudes das naves em uma posi√ß√£o m√©dia do campo
        team1.posY = battlefieldHeight / 2;
        team2.posY = battlefieldHeight / 2;

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Radar scan para detectar proj√©teis
            team1.radarScan(projectiles, p2PosX, team2.getPositionY());
            team2.radarScan(projectiles, p1PosX, team1.getPositionY());

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar para Time 1
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team1.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team1.nuclearMissile(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 1 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team1.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team1.doubleShot(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚û°Ô∏è Time 1 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team1.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p1PosX, secAlt, 1, 1, "->", team1.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    // Tiro normal
                    shot = team1.shoot(p1PosX, 1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Atirar para Time 2
            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team2.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team2.nuclearMissile(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 2 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team2.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team2.doubleShot(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚¨ÖÔ∏è Time 2 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team2.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p2PosX, secAlt, -1, 1, "<-", team2.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    // Tiro normal
                    shot = team2.shoot(p2PosX, -1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha com cores
            battlefield[team1.getPositionY()][p1PosX] = "\u001B[34m" + team1.symbol + "\u001B[0m";  // Azul para Time 1
            battlefield[team2.getPositionY()][p2PosX] = "\u001B[31m" + team2.symbol + "\u001B[0m";  // Vermelho para Time 2

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes com Time 1
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("<[=-")) {{ // M√≠ssil nuclear do Time 2
                        damage = team2.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 2 atingiu o Time 1!");
                    }} else if (p.symbol.contains("‚áá")) {{ // Tiro duplo do Time 2
                        damage = team2.doubleShotPower;
                    }} else if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                        if (team1.radar > 0) {{
                            System.out.println("üì° Radar do Time 1 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Verificar colis√µes com Time 2
                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("-]=>")) {{ // M√≠ssil nuclear do Time 1
                        damage = team1.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 1 atingiu o Time 2!");
                    }} else if (p.symbol.contains("‚áâ")) {{ // Tiro duplo do Time 1
                        damage = team1.doubleShotPower;
                    }} else if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                        if (team2.radar > 0) {{
                            System.out.println("üì° Radar do Time 2 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha com cores
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    // Adicionar cores aos proj√©teis baseado na dire√ß√£o
                    if (p.direction > 0) {{
                        battlefield[p.posY][p.posX] = "\u001B[34m" + p.symbol + "\u001B[0m";  // Azul para Time 1
                    }} else {{
                        battlefield[p.posY][p.posX] = "\u001B[31m" + p.symbol + "\u001B[0m";  // Vermelho para Time 2
                    }}
                }}
            }}  // Fechamento do while

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar os arquivos Java
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

       # Executar a simula√ß√£o
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        # Usar deque para manter os √∫ltimos turnos apenas
        from collections import deque
        turnos = deque(maxlen=5)  # Guardar apenas os √∫ltimos 5 turnos
        turno_atual = ""

        # Flag se estamos no meio de um turno
        coletando_turno = False

        # Para detectar o final
        resultado_final = None

        for line in iter(process.stdout.readline, ""):
            # Detectar novo turno
            if "=== NOVO TURNO ===" in line:
                if turno_atual:
                    turnos.append(turno_atual)
                turno_atual = line
                coletando_turno = True
            elif coletando_turno:
                turno_atual += line

            # Verificar se √© o resultado final
            if "venceu" in line:
                resultado_final = line
                # Sempre atualizar no final
                yield render_battlefield(turnos, turno_atual, final=True)
                continue

            # Atualizar a cada turno
            yield render_battlefield(turnos, turno_atual)

            # Pausa pequena entre atualiza√ß√µes
            import time
            time.sleep(0.05)

        # Garantir exibi√ß√£o final uma vez mais
        yield render_battlefield(turnos, turno_atual, final=True)

        # [c√≥digo de tratamento de erro igual]
    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

def render_battlefield(turnos, turno_atual, final=False):
    # Construir o texto: turnos anteriores + turno atual
    texto = "".join(list(turnos)) + turno_atual

    # Convers√£o de cores
    texto = texto.replace("\033[31m", "<span style='color:red;'>")
    texto = texto.replace("\033[34m", "<span style='color:blue;'>")
    texto = texto.replace("\033[32m", "<span style='color:green;'>")
    texto = texto.replace("\033[0m", "</span>")

    # Script para scroll - mais direto
    scroll_js = """
    <script>
    (function() {
        document.getElementById('battle-container').scrollTop = 999999;
    })();
    </script>
    """

    # Script mais forte para o final
    if final:
        scroll_js = """
        <script>
        (function() {
            var scrollToEnd = function() {
                document.getElementById('battle-container').scrollTop = 999999;
            };
            scrollToEnd();
            setTimeout(scrollToEnd, 100);
            setTimeout(scrollToEnd, 300);
            setTimeout(scrollToEnd, 500);
        })();
        </script>
        """

    return f"""
    <div id="battle-container" style="height:400px; overflow:auto; border:1px solid #ccc; padding:10px;
                                     font-family:monospace; white-space:pre; background-color:#f8f8f8;
                                     scroll-behavior: smooth; display:block; visibility:visible;">
        {texto}
    </div>
    {scroll_js}
    """

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha

    **NOVIDADES**: Agora suas aeronaves podem ter radar para detectar proj√©teis, tiro duplo para atacar em duas altitudes diferentes e at√© m√≠sseis nucleares para dano massivo!
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # Adicionando configura√ß√µes de vida
        with gr.Row():
            team1_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 1", info="Define a vida inicial da aeronave do Time 1")
            team2_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 2", info="Define a vida inicial da aeronave do Time 2")

        # Bot√£o para equalizar as vidas (opcional)
        def equalize_health(health_value):
            return health_value, health_value

        equalize_btn = gr.Button("üîÑ Igualar Vidas")
        equalize_btn.click(fn=equalize_health, inputs=team1_health, outputs=[team1_health, team2_health])

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos, t1_health, t2_health):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos, t1_health, t2_health):
            yield output

    btn = gr.Button("üî• Combate!")
    #output = gr.Textbox(label="Resultado do Combate", lines=30)
    # Configurar o componente HTML com CSS adicional para visibilidade imediata
    css = """
   <style>
   #battle-result .prose {
    padding: 0 !important;
    margin: 0 !important;
    display: block !important;
    visibility: visible !important;
    }
    </style>
    """

    output = gr.HTML(label="Resultado do Combate", elem_id="battle-result", value=css)
    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria com os novos par√¢metros de vida
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos,
                     team1_health, team2_health],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - O radar permite detectar proj√©teis inimigos e realizar manobras evasivas autom√°ticas.
    - O tiro duplo ataca em duas altitudes ao mesmo tempo, aumentando suas chances de acerto.
    - O m√≠ssil nuclear causa dano massivo, mas tem um longo cooldown de 5 turnos.
    - Use toda a altura do campo (configure nas op√ß√µes) para estrat√©gias mais interessantes!
    - Agora voc√™ pode ajustar a vida inicial das aeronaves para batalhas mais longas ou equilibrar times desiguais!

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves com altura din√¢mica e novos atributos
TEAM1_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áâ");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "-]=>");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

TEAM2_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áá");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "<[=-");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

# C√≥digo base das classes Aircraft e Projectile atualizados com os novos recursos
aircraft_code = """
import java.util.ArrayList;

public abstract class Aircraft {
    protected int health;  // Agora definido externamente
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int radar;
    protected int doubleShot;
    protected int doubleShotPower;
    protected int nuclearPower;
    protected int secondShotAltitude = -1;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, int radar, int doubleShot,
                    int nuclearPower, String symbol) {
        this.health = 100;  // Valor padr√£o que ser√° substitu√≠do
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.radar = radar;
        this.doubleShot = doubleShot;
        this.doubleShotPower = doubleShot;
        this.nuclearPower = nuclearPower;
        this.symbol = symbol;

        validateAttributes();
    }

    public void setInitialHealth(int health) {
        this.health = health;
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower +
                   missilePower + defense + stealthChance + radar + doubleShot + nuclearPower;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos! Total: " + total);
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);
    public abstract Projectile doubleShot(int posX, int direction);
    public abstract Projectile nuclearMissile(int posX, int direction);
    public abstract void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSecondShotAltitude() {
        int alt = secondShotAltitude;
        secondShotAltitude = -1; // Reset ap√≥s uso
        return alt;
    }
}
"""

projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;
    int power = 0;  // Poder do proj√©til, usado para dano personalizado

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public Projectile(int posX, int posY, int direction, int speed, String symbol, int power) {
        this(posX, posY, direction, speed, symbol);
        this.power = power;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }

    public int getPower() {
        return power;
    }
}
"""
def format_battle_text(output):
    # Processar as cores ANSI para HTML
    output = output.replace("\033[31m", "<span style='color:red;'>")   # Time 2 (Vermelho)
    output = output.replace("\033[34m", "<span style='color:blue;'>")  # Time 1 (Azul)
    output = output.replace("\033[32m", "<span style='color:green;'>") # Outros elementos
    output = output.replace("\033[0m", "</span>")  # Reset de cor

    # Script de scroll muito mais agressivo para garantir que acompanhe os novos turnos
    scroll_script = """
    <script>
    (function() {
        // Fun√ß√£o robusta de scroll que vai para o final
        function forceScroll() {
            const container = document.getElementById('battle-container');
            if (container) {
                // For√ßar scroll para o final de qualquer jeito
                container.scrollTop = 999999;

                // Garantir que o pr√≥ximo render tamb√©m mantenha o scroll
                setTimeout(() => { container.scrollTop = 999999; }, 10);
                setTimeout(() => { container.scrollTop = 999999; }, 50);
            }
        }

        // Roda imediatamente e tamb√©m com curto atraso
        forceScroll();

        // Tamb√©m configura um intervalo para constantly verificar e ajustar o scroll
        // Isto vai garantir que mesmo com atualiza√ß√µes r√°pidas, o scroll acompanhe
        const scrollInterval = setInterval(forceScroll, 100);

        // Para o intervalo ap√≥s 30 segundos para n√£o consumir recursos indefinidamente
        setTimeout(() => { clearInterval(scrollInterval); }, 30000);
    })();
    </script>
    """

    # Para o final da simula√ß√£o, vamos usar um scroll ainda mais forte
    if "venceu" in output:
        scroll_script = """
        <script>
        (function() {
            function finalScroll() {
                const container = document.getElementById('battle-container');
                if (container) {
                    container.scrollTop = container.scrollHeight * 2;
                }
            }

            // Roda m√∫ltiplas vezes com delays crescentes para garantir que pegue o final
            finalScroll();
            for (let i = 1; i <= 10; i++) {
                setTimeout(finalScroll, i * 200);
            }
        })();
        </script>
        """

    # Reduzir a quantidade de conte√∫do para melhorar performance
    # Divide em turnos e pega s√≥ os √∫ltimos para melhor desempenho
    turnos = output.split("=== NOVO TURNO ===")
    if len(turnos) > 10 and "venceu" not in output:  # Se tiver muitos turnos e n√£o for o final
        output = "=== NOVO TURNO ===".join(turnos.slice(-8))  # Mostra s√≥ os √∫ltimos 8 turnos

    return f"""
    <div id="battle-container" style="height:500px; overflow:auto; border:1px solid #ccc; padding:10px;
                                     font-family:monospace; white-space:pre; background-color:#f8f8f8;">
        {output}
    </div>
    {scroll_script}
    """

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos, team1_health, team2_health):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # Gerar o c√≥digo do BattleMain com os par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        // Definir a altura do campo como propriedade do sistema
        System.setProperty("battlefield.height", "{battlefield_height}");

        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        // Definir a vida inicial de cada aeronave
        team1.setInitialHealth({team1_health});
        team2.setInitialHealth({team2_health});

        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        // Inicializar as altitudes das naves em uma posi√ß√£o m√©dia do campo
        team1.posY = battlefieldHeight / 2;
        team2.posY = battlefieldHeight / 2;

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Radar scan para detectar proj√©teis
            team1.radarScan(projectiles, p2PosX, team2.getPositionY());
            team2.radarScan(projectiles, p1PosX, team1.getPositionY());

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar para Time 1
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team1.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team1.nuclearMissile(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 1 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team1.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team1.doubleShot(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚û°Ô∏è Time 1 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team1.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p1PosX, secAlt, 1, 1, "->", team1.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    // Tiro normal
                    shot = team1.shoot(p1PosX, 1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Atirar para Time 2
            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team2.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team2.nuclearMissile(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 2 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team2.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team2.doubleShot(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚¨ÖÔ∏è Time 2 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team2.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p2PosX, secAlt, -1, 1, "<-", team2.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    // Tiro normal
                    shot = team2.shoot(p2PosX, -1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha com cores
            battlefield[team1.getPositionY()][p1PosX] = "\u001B[34m" + team1.symbol + "\u001B[0m";  // Azul para Time 1
            battlefield[team2.getPositionY()][p2PosX] = "\u001B[31m" + team2.symbol + "\u001B[0m";  // Vermelho para Time 2

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes com Time 1
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("<[=-")) {{ // M√≠ssil nuclear do Time 2
                        damage = team2.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 2 atingiu o Time 1!");
                    }} else if (p.symbol.contains("‚áá")) {{ // Tiro duplo do Time 2
                        damage = team2.doubleShotPower;
                    }} else if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                        if (team1.radar > 0) {{
                            System.out.println("üì° Radar do Time 1 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Verificar colis√µes com Time 2
                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("-]=>")) {{ // M√≠ssil nuclear do Time 1
                        damage = team1.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 1 atingiu o Time 2!");
                    }} else if (p.symbol.contains("‚áâ")) {{ // Tiro duplo do Time 1
                        damage = team1.doubleShotPower;
                    }} else if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                        if (team2.radar > 0) {{
                            System.out.println("üì° Radar do Time 2 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha com cores
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    // Adicionar cores aos proj√©teis baseado na dire√ß√£o
                    if (p.direction > 0) {{
                        battlefield[p.posY][p.posX] = "\u001B[34m" + p.symbol + "\u001B[0m";  // Azul para Time 1
                    }} else {{
                        battlefield[p.posY][p.posX] = "\u001B[31m" + p.symbol + "\u001B[0m";  // Vermelho para Time 2
                    }}
                }}
            }}  // Fechamento do while

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar os arquivos Java
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        # Executar a simula√ß√£o
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        # Usar deque para manter os √∫ltimos turnos na visualiza√ß√£o
        from collections import deque
        turnos = deque(maxlen=4)  # √öltimos 5 turnos para visualiza√ß√£o fluida

        # Guardar sa√≠da completa
        saida_completa = ""

        turno_atual = ""
        coletando_turno = False

        # Para detectar o final
        resultado_final = None

        for line in iter(process.stdout.readline, ""):
            saida_completa += line

            # Detectar novo turno
            if "=== NOVO TURNO ===" in line:
                if turno_atual:
                    turnos.append(turno_atual)
                turno_atual = line
                coletando_turno = True
            elif coletando_turno:
                turno_atual += line

            # Verificar se √© o resultado final
            if "venceu" in line:
                resultado_final = line

            # Atualizar a cada turno (visualiza√ß√£o fluida com poucos turnos)
            texto = "".join(list(turnos)) + turno_atual

            # Convers√£o de cores
            formatted_texto = texto.replace("\033[31m", "<span style='color:red;'>")
            formatted_texto = formatted_texto.replace("\033[34m", "<span style='color:blue;'>")
            formatted_texto = formatted_texto.replace("\033[32m", "<span style='color:green;'>")
            formatted_texto = formatted_texto.replace("\033[0m", "</span>")

            # Script de scroll
            scroll_js = """
            <script>
            (function() {
                document.getElementById('battle-container').scrollTop = 999999;
            })();
            </script>
            """

            html_output = f"""
            <div id="battle-container" style="height:400px; overflow:auto; border:1px solid #ccc; padding:10px;
                                             font-family:monospace; white-space:pre; background-color:#f8f8f8;">
                {formatted_texto}
            </div>
            {scroll_js}
            """

            yield html_output

            # Pausa pequena entre atualiza√ß√µes
            import time
            time.sleep(0.05)

        # Ao final, mostrar resultado destacado e hist√≥rico completo
        if resultado_final:
            # Formatar toda a sa√≠da
            formatted_saida = saida_completa.replace("\033[31m", "<span style='color:red;'>")
            formatted_saida = formatted_saida.replace("\033[34m", "<span style='color:blue;'>")
            formatted_saida = formatted_saida.replace("\033[32m", "<span style='color:green;'>")
            formatted_saida = formatted_saida.replace("\033[0m", "</span>")

            # Detectar o vencedor para colorir o resultado
            vencedor = "Time 1" if "Time 1 venceu" in resultado_final else "Time 2"
            cor = "blue" if vencedor == "Time 1" else "red"

            # Montar o HTML final com resultado e hist√≥rico completo
            final_html = f"""
            <div>
                <div style="padding:15px; background-color:#e9f7e9; border:2px solid #4CAF50;
                            margin:15px 0; text-align:center; border-radius:5px;">
                    <h3 style="color:{cor}; margin:0; font-size:24px;">üèÜ {vencedor} VENCEU! üèÜ</h3>
                </div>

                <h4>Hist√≥rico Completo da Batalha:</h4>

                <div style="height:500px; overflow:auto; border:1px solid #ccc; padding:10px;
                           font-family:monospace; white-space:pre; background-color:#f8f8f8;">
                    {formatted_saida}
                </div>
            </div>
            """

            yield final_html

        # [c√≥digo de tratamento de erro igual]
    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

def render_battlefield(turnos, turno_atual, resultado_final=None, final=False):
    # Construir o texto: turnos anteriores + turno atual + resultado final
    texto = "".join(list(turnos)) + turno_atual
    if resultado_final and resultado_final not in texto:
        texto += resultado_final

    # Convers√£o de cores
    texto = texto.replace("\033[31m", "<span style='color:red;'>")
    texto = texto.replace("\033[34m", "<span style='color:blue;'>")
    texto = texto.replace("\033[32m", "<span style='color:green;'>")
    texto = texto.replace("\033[0m", "</span>")

    # Script para scroll imediato
    scroll_js = """
    <script>
    (function() {
        const container = document.getElementById('battle-container');
        container.scrollTop = container.scrollHeight + 9999;
    })();
    </script>
    """

    # Script mais forte para o final
    if final:
        scroll_js = """
        <script>
        (function() {
            const container = document.getElementById('battle-container');
            // Scroll imediato
            container.scrollTop = container.scrollHeight * 2;

            // Repetir v√°rias vezes com atrasos
            for (let i = 1; i <= 10; i++) {
                setTimeout(() => {
                    container.scrollTop = container.scrollHeight * 2;
                }, i * 100);
            }
        })();
        </script>
        """

    return f"""
    <div id="battle-container" style="height:400px; overflow:auto; border:1px solid #ccc; padding:10px;
                                     font-family:monospace; white-space:pre; background-color:#f8f8f8;
                                     scroll-behavior: smooth; display:block; visibility:visible;">
        {texto}
    </div>
    {scroll_js}
    """

def render_historico_completo(historico, resultado_final=None):
    # Construir o texto completo
    texto_completo = "".join(historico)
    if resultado_final and resultado_final not in texto_completo:
        texto_completo += resultado_final

    # Convers√£o de cores
    texto_completo = texto_completo.replace("\033[31m", "<span style='color:red;'>")
    texto_completo = texto_completo.replace("\033[34m", "<span style='color:blue;'>")
    texto_completo = texto_completo.replace("\033[32m", "<span style='color:green;'>")
    texto_completo = texto_completo.replace("\033[0m", "</span>")

    # Destacar resultado
    if resultado_final:
        vencedor = "Time 1" if "Time 1 venceu" in resultado_final else "Time 2"
        cor = "blue" if vencedor == "Time 1" else "red"
        resultado_html = f'<div style="padding:10px; background-color:#e9f7e9; border:2px solid #4CAF50; margin:10px 0; text-align:center;"><h3 style="color:{cor}; margin:0;">üèÜ {vencedor} VENCEU! üèÜ</h3></div>'
    else:
        resultado_html = ""

    # Hist√≥rico expans√≠vel com bot√£o
    return f"""
    {resultado_html}
    <div style="margin-top:10px;">
        <button onclick="toggleHistorico()" style="padding:5px 10px; margin-bottom:10px; cursor:pointer;">
            Mostrar hist√≥rico completo da batalha
        </button>

        <div id="historico-completo" style="display:none; height:500px; overflow:auto; border:1px solid #ccc;
                                         padding:10px; font-family:monospace; white-space:pre; background-color:#f8f8f8;">
            {texto_completo}
        </div>
    </div>

    <script>
    function toggleHistorico() {{
        var el = document.getElementById('historico-completo');
        var btn = el.previousElementSibling;

        if (el.style.display === 'none') {{
            el.style.display = 'block';
            btn.textContent = 'Ocultar hist√≥rico completo';

            // Scroll para o final quando expandir
            setTimeout(function() {{
                el.scrollTop = el.scrollHeight;
            }}, 100);
        }} else {{
            el.style.display = 'none';
            btn.textContent = 'Mostrar hist√≥rico completo da batalha';
        }}
    }}
    </script>
    """

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚úàÔ∏è Arena de Combate - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha

    **NOVIDADES**: Agora suas aeronaves podem ter radar para detectar proj√©teis, tiro duplo para atacar em duas altitudes diferentes e at√© m√≠sseis nucleares para dano massivo!
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # Adicionando configura√ß√µes de vida
        with gr.Row():
            team1_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 1", info="Define a vida inicial da aeronave do Time 1")
            team2_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 2", info="Define a vida inicial da aeronave do Time 2")

        # Bot√£o para equalizar as vidas (opcional)
        def equalize_health(health_value):
            return health_value, health_value

        equalize_btn = gr.Button("üîÑ Igualar Vidas")
        equalize_btn.click(fn=equalize_health, inputs=team1_health, outputs=[team1_health, team2_health])

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos, t1_health, t2_health):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos, t1_health, t2_health):
            yield output

    btn = gr.Button("üî• Combate!")
    #output = gr.Textbox(label="Resultado do Combate", lines=30)
    # Configurar o componente HTML com CSS adicional para visibilidade imediata
    css = """
   <style>
   #battle-result .prose {
    padding: 0 !important;
    margin: 0 !important;
    display: block !important;
    visibility: visible !important;
    }
    </style>
    """

    output = gr.HTML(label="Resultado do Combate", elem_id="battle-result", value=css)
    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria com os novos par√¢metros de vida
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos,
                     team1_health, team2_health],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - O radar permite detectar proj√©teis inimigos e realizar manobras evasivas autom√°ticas.
    - O tiro duplo ataca em duas altitudes ao mesmo tempo, aumentando suas chances de acerto.
    - O m√≠ssil nuclear causa dano massivo, mas tem um longo cooldown de 5 turnos.
    - Use toda a altura do campo (configure nas op√ß√µes) para estrat√©gias mais interessantes!
    - Agora voc√™ pode ajustar a vida inicial das aeronaves para batalhas mais longas ou equilibrar times desiguais!

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

"""Em cima ate q funciona, mas quando termina, o scroll vai la pra cima..."""

import gradio as gr
import os
import subprocess

# Criar pasta para armazenar as classes Java
os.makedirs("combat_classes", exist_ok=True)

# Templates de c√≥digo para as aeronaves com altura din√¢mica e novos atributos
TEAM1_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 1 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team1Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team1Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚ñ∂" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "->");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, ">>");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "=>");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áâ");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "-]=>");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

TEAM2_TEMPLATE = '''import java.util.ArrayList;
import java.util.Random;

/**
 * Time 2 - Configure sua aeronave!
 *
 * SISTEMA DE PONTOS:
 * - Voc√™ tem 100 pontos para distribuir entre os atributos
 * - Escolha com sabedoria para criar uma aeronave competitiva
 *
 * ATRIBUTOS:
 * - speed: Velocidade da aeronave (1-10) - Afeta qu√£o r√°pido sua aeronave pode se mover
 * - fireRate: Taxa de disparo (1-10) - Controla com que frequ√™ncia sua aeronave pode atirar
 * - maneuverability: Manobrabilidade (1-10) - Facilita mudan√ßas de altitude e esquivas
 * - shotPower: Poder do tiro normal (5-20) - Dano causado por tiros normais
 * - supersonicPower: Poder do tiro supers√¥nico (10-30) - Dano causado por tiros supers√¥nicos
 * - missilePower: Poder do m√≠ssil (15-40) - Dano causado pelo m√≠ssil especial
 * - defense: Defesa (5-25) - Reduz o dano recebido
 * - stealthChance: Chance de furtividade (0-20) - Probabilidade de evitar ataques
 * - radar: Radar (0-10) - Capacidade de detectar proj√©teis inimigos
 * - doubleShot: Tiro duplo (0-10) - Permite disparar em duas altitudes diferentes
 * - nuclearPower: Poder nuclear (0-10) - Poder do m√≠ssil nuclear (dano massivo)
 */
public class Team2Aircraft extends Aircraft {
    private Random random = new Random();
    private int maxAltitude; // Armazena a altura m√°xima do campo

    public Team2Aircraft() {
        super(
            // DISTRIBUA 100 PONTOS ENTRE ESSES ATRIBUTOS
            5,  // Velocidade (1-10)
            5,  // Taxa de fogo (1-10)
            5,  // Manobrabilidade (1-10)
            15, // Dano do tiro normal (5-20)
            20, // Dano do tiro supers√¥nico (10-30)
            25, // Dano do m√≠ssil (15-40)
            15, // Defesa (5-25)
            5,  // Chance de furtividade (0-20)
            2,  // Radar (0-10)
            2,  // Tiro duplo (0-10)
            1,  // Poder nuclear (0-10)
            "‚óÄ" // S√≠mbolo da aeronave (n√£o altere)
        );

        // IMPORTANTE: A soma de todos os atributos deve ser <= 100
        // Exemplo: 5+5+5+15+20+25+15+5+2+2+1 = 100

        // Verifica dinamicamente a altura do campo (ser√° definida pelo BattleMain)
        try {
            String heightEnv = System.getProperty("battlefield.height", "3");
            maxAltitude = Integer.parseInt(heightEnv) - 1;
        } catch (Exception e) {
            maxAltitude = 2; // Valor padr√£o se n√£o conseguir ler
        }
    }

    /**
     * Controla o movimento da aeronave.
     * Valor padr√£o: Movimento aleat√≥rio baseado na velocidade
     * Dica: Voc√™ pode personalizar para criar padr√µes de movimento mais inteligentes
     */
    @Override
    public int move() {
        // Retorna um n√∫mero entre -speed/2 e +speed
        return random.nextInt(speed + 1) - speed / 2;
    }

    /**
     * Controla a mudan√ßa de altitude da aeronave.
     * Valor padr√£o: Mudan√ßa aleat√≥ria entre subir, descer ou manter altitude
     * Dica: Uma boa estrat√©gia pode aumentar suas chances de esquiva
     */
    @Override
    public int changeAltitude() {
        int direction = random.nextInt(3) - 1; // -1 (descer), 0 (manter), 1 (subir)
        this.posY = Math.max(0, Math.min(maxAltitude, posY + direction));
        return direction;
    }

    /**
     * Tiro normal - mais frequente, menos dano
     */
    @Override
    public Projectile shoot(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 1, "<-");
    }

    /**
     * Tiro supers√¥nico - mais r√°pido, mais dano
     */
    @Override
    public Projectile shootSupersonic(int posX, int direction) {
        return new Projectile(posX, this.posY, direction, 2, "<<");
    }

    /**
     * M√≠ssil especial - muito dano, com cooldown
     */
    @Override
    public Projectile specialMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 3; // Espera 3 turnos para usar novamente
            return new Projectile(posX, this.posY, direction, 1, "<=");
        }
        missileCooldown--;
        return null;
    }

    /**
     * Tiro duplo - ataca em duas altitudes diferentes
     */
    @Override
    public Projectile doubleShot(int posX, int direction) {
        // Define a segunda altitude para o tiro (diferente da atual)
        int currentAlt = this.posY;
        int secondAlt = (currentAlt + 1) % (maxAltitude + 1);

        // Guarda essa altitude para ser usada pelo BattleMain
        this.secondShotAltitude = secondAlt;

        // Retorna o proj√©til principal
        return new Projectile(posX, this.posY, direction, 1, "‚áá");
    }

    /**
     * M√≠ssil nuclear - dano massivo
     */
    @Override
    public Projectile nuclearMissile(int posX, int direction) {
        if (missileCooldown == 0) {
            missileCooldown = 5; // Longo cooldown para o poder nuclear
            return new Projectile(posX, this.posY, direction, 1, "<[=-");
        }
        return null;
    }

    /**
     * Radar - detecta proj√©teis inimigos
     */
    @Override
    public void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY) {
        // Implementa√ß√£o b√°sica: apenas detecta proj√©teis pr√≥ximos
        // Em uma implementa√ß√£o mais avan√ßada, voc√™ poderia usar essas informa√ß√µes
        // para ajustar seu movimento e evitar proj√©teis
    }
}'''

# C√≥digo base das classes Aircraft e Projectile atualizados com os novos recursos
aircraft_code = """
import java.util.ArrayList;

public abstract class Aircraft {
    protected int health;  // Agora definido externamente
    protected int speed;
    protected int fireRate;
    protected int maneuverability;
    protected int shotPower;
    protected int supersonicPower;
    protected int missilePower;
    protected int defense;
    protected int stealthChance;
    protected int radar;
    protected int doubleShot;
    protected int doubleShotPower;
    protected int nuclearPower;
    protected int secondShotAltitude = -1;
    protected int missileCooldown = 0;
    protected int posY = 1;
    protected String symbol;
    protected static final int TOTAL_POINTS = 100;

    public Aircraft(int speed, int fireRate, int maneuverability, int shotPower, int supersonicPower,
                    int missilePower, int defense, int stealthChance, int radar, int doubleShot,
                    int nuclearPower, String symbol) {
        this.health = 100;  // Valor padr√£o que ser√° substitu√≠do
        this.speed = speed;
        this.fireRate = fireRate;
        this.maneuverability = maneuverability;
        this.shotPower = shotPower;
        this.supersonicPower = supersonicPower;
        this.missilePower = missilePower;
        this.defense = defense;
        this.stealthChance = stealthChance;
        this.radar = radar;
        this.doubleShot = doubleShot;
        this.doubleShotPower = doubleShot;
        this.nuclearPower = nuclearPower;
        this.symbol = symbol;

        validateAttributes();
    }

    public void setInitialHealth(int health) {
        this.health = health;
    }

    private void validateAttributes() {
        int total = speed + fireRate + maneuverability + shotPower + supersonicPower +
                   missilePower + defense + stealthChance + radar + doubleShot + nuclearPower;
        if (total > TOTAL_POINTS) {
            throw new IllegalArgumentException("Erro: A soma dos atributos excede " + TOTAL_POINTS + " pontos! Total: " + total);
        }
    }

    public abstract int move();
    public abstract int changeAltitude();
    public abstract Projectile shoot(int posX, int direction);
    public abstract Projectile shootSupersonic(int posX, int direction);
    public abstract Projectile specialMissile(int posX, int direction);
    public abstract Projectile doubleShot(int posX, int direction);
    public abstract Projectile nuclearMissile(int posX, int direction);
    public abstract void radarScan(ArrayList<Projectile> projectiles, int enemyPosX, int enemyPosY);

    public int getHealth() {
        return health;
    }

    public void takeDamage(int damage) {
        this.health -= Math.max(0, damage - (defense / 10));
    }

    public boolean isAlive() {
        return health > 0;
    }

    public int getPositionY() {
        return posY;
    }

    public int getSecondShotAltitude() {
        int alt = secondShotAltitude;
        secondShotAltitude = -1; // Reset ap√≥s uso
        return alt;
    }
}
"""

projectile_code = """
public class Projectile {
    int posX;
    int posY;
    int direction;
    int speed;
    String symbol;
    int power = 0;  // Poder do proj√©til, usado para dano personalizado

    public Projectile(int posX, int posY, int direction, int speed, String symbol) {
        this.posX = posX;
        this.posY = posY;
        this.direction = direction;
        this.speed = speed;
        this.symbol = symbol;
    }

    public Projectile(int posX, int posY, int direction, int speed, String symbol, int power) {
        this(posX, posY, direction, speed, symbol);
        this.power = power;
    }

    public void move() {
        posX += direction * speed;
    }

    public boolean isOutOfBounds(int screenWidth) {
        return (posX < 0 || posX >= screenWidth);
    }

    public int getPower() {
        return power;
    }
}
"""
def format_battle_text(output):
    # Processar as cores ANSI para HTML
    output = output.replace("\033[31m", "<span style='color:red;'>")   # Time 2 (Vermelho)
    output = output.replace("\033[34m", "<span style='color:blue;'>")  # Time 1 (Azul)
    output = output.replace("\033[32m", "<span style='color:green;'>") # Outros elementos
    output = output.replace("\033[0m", "</span>")  # Reset de cor

    # Script de scroll muito mais agressivo para garantir que acompanhe os novos turnos
    scroll_script = """
    <script>
    (function() {
        // Fun√ß√£o robusta de scroll que vai para o final
        function forceScroll() {
            const container = document.getElementById('battle-container');
            if (container) {
                // For√ßar scroll para o final de qualquer jeito
                container.scrollTop = container.scrollHeight * 10;

                // Garantir que o pr√≥ximo render tamb√©m mantenha o scroll
                setTimeout(() => { container.scrollTop = container.scrollHeight * 10; }, 50);
                setTimeout(() => { container.scrollTop = container.scrollHeight * 10; }, 100);
                setTimeout(() => { container.scrollTop = container.scrollHeight * 10; }, 200);
            }
        }

        // Roda imediatamente e tamb√©m com curto atraso
        forceScroll();

        // Tamb√©m configura um intervalo para constantly verificar e ajustar o scroll
        // Isto vai garantir que mesmo com atualiza√ß√µes r√°pidas, o scroll acompanhe
        const scrollInterval = setInterval(forceScroll, 100);

        // Para o intervalo ap√≥s 30 segundos para n√£o consumir recursos indefinidamente
        setTimeout(() => { clearInterval(scrollInterval); }, 30000);

        // Observer para detectar mudan√ßas no conte√∫do
        const observer = new MutationObserver(forceScroll);
        const container = document.getElementById('battle-container');
        if (container) {
            observer.observe(container, { childList: true, subtree: true });
        }
    })();
    </script>
    """

    # Para o final da simula√ß√£o, vamos usar um scroll ainda mais forte
    if "venceu" in output:
        scroll_script = """
        <script>
        (function() {
            function finalScroll() {
                const container = document.getElementById('battle-container');
                if (container) {
                    container.scrollTop = container.scrollHeight * 20;
                }
            }

            // Roda m√∫ltiplas vezes com delays crescentes para garantir que pegue o final
            finalScroll();
            for (let i = 1; i <= 20; i++) {
                setTimeout(finalScroll, i * 100);
            }

            // Continua verificando por alguns segundos
            const scrollInterval = setInterval(finalScroll, 200);
            setTimeout(() => { clearInterval(scrollInterval); }, 5000);
        })();
        </script>
        """

    # Reduzir a quantidade de conte√∫do para melhorar performance
    # Divide em turnos e pega s√≥ os √∫ltimos para melhor desempenho
    turnos = output.split("=== NOVO TURNO ===")
    if len(turnos) > 10 and "venceu" not in output:  # Se tiver muitos turnos e n√£o for o final
        output = "=== NOVO TURNO ===".join(turnos[-8:])  # Mostra s√≥ os √∫ltimos 8 turnos

    return f"""
    <div id="battle-container" style="height:500px; overflow:auto; border:1px solid #ccc; padding:10px;
                                     font-family:monospace; white-space:pre; background-color:#f8f8f8;">
        {output}
    </div>
    {scroll_script}
    """

def run_battle(code1, code2, screen_width, battlefield_height, p1_start_pos, p2_start_pos, team1_health, team2_health):
    # Caminhos dos arquivos Java
    aircraft_path = "combat_classes/Aircraft.java"
    projectile_path = "combat_classes/Projectile.java"
    class1_path = "combat_classes/Team1Aircraft.java"
    class2_path = "combat_classes/Team2Aircraft.java"
    main_path = "combat_classes/BattleMain.java"

    # Gerar o c√≥digo do BattleMain com os par√¢metros configur√°veis
    battle_main_code = f"""
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

public class BattleMain {{
    public static void main(String[] args) {{
        // Definir a altura do campo como propriedade do sistema
        System.setProperty("battlefield.height", "{battlefield_height}");

        Aircraft team1 = new Team1Aircraft();
        Aircraft team2 = new Team2Aircraft();

        // Definir a vida inicial de cada aeronave
        team1.setInitialHealth({team1_health});
        team2.setInitialHealth({team2_health});

        Random random = new Random();

        int p1PosX = {p1_start_pos};
        int p2PosX = {p2_start_pos};
        int screenWidth = {screen_width};
        int battlefieldHeight = {battlefield_height};
        ArrayList<Projectile> projectiles = new ArrayList<>();

        // Inicializar as altitudes das naves em uma posi√ß√£o m√©dia do campo
        team1.posY = battlefieldHeight / 2;
        team2.posY = battlefieldHeight / 2;

        while (team1.isAlive() && team2.isAlive()) {{
            System.out.println("\\n=== NOVO TURNO ===");
            System.out.flush();

            String[][] battlefield = new String[battlefieldHeight][screenWidth];
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    battlefield[row][i] = " ";
                }}
            }}

            // Radar scan para detectar proj√©teis
            team1.radarScan(projectiles, p2PosX, team2.getPositionY());
            team2.radarScan(projectiles, p1PosX, team1.getPositionY());

            // Movimento das aeronaves
            p1PosX += team1.move();
            p2PosX += team2.move();
            p1PosX = Math.max(0, Math.min(screenWidth - 1, p1PosX));
            p2PosX = Math.max(0, Math.min(screenWidth - 1, p2PosX));

            // Mudan√ßa de altitude
            team1.changeAltitude();
            team2.changeAltitude();
            // Garantir que a altitude n√£o exceda o novo tamanho do campo de batalha
            team1.posY = Math.min(team1.posY, battlefieldHeight - 1);
            team2.posY = Math.min(team2.posY, battlefieldHeight - 1);

            // Atirar para Time 1
            if (random.nextInt(10) < team1.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team1.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team1.nuclearMissile(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 1 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team1.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team1.doubleShot(p1PosX, 1);
                    if (shot != null) {{
                        System.out.println("‚û°Ô∏è Time 1 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team1.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p1PosX, secAlt, 1, 1, "->", team1.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team1.specialMissile(p1PosX, 1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team1.shootSupersonic(p1PosX, 1);
                }} else {{
                    // Tiro normal
                    shot = team1.shoot(p1PosX, 1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Atirar para Time 2
            if (random.nextInt(10) < team2.fireRate) {{
                Projectile shot = null;
                int shotType = random.nextInt(100);

                // Escolha aleat√≥ria do tipo de tiro baseado na probabilidade
                if (shotType < 5 && team2.nuclearPower > 0) {{
                    // Tiro nuclear (baixa probabilidade)
                    shot = team2.nuclearMissile(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚ò¢Ô∏è Time 2 lan√ßou um M√çSSIL NUCLEAR!");
                    }}
                }} else if (shotType < 15 && team2.doubleShot > 0) {{
                    // Tiro duplo
                    shot = team2.doubleShot(p2PosX, -1);
                    if (shot != null) {{
                        System.out.println("‚¨ÖÔ∏è Time 2 disparou um TIRO DUPLO!");
                        // Adicionar o segundo proj√©til em uma altitude diferente
                        int secAlt = team2.getSecondShotAltitude();
                        if (secAlt >= 0 && secAlt < battlefieldHeight) {{
                            projectiles.add(new Projectile(p2PosX, secAlt, -1, 1, "<-", team2.doubleShotPower));
                        }}
                    }}
                }} else if (shotType < 30) {{
                    // M√≠ssil especial
                    shot = team2.specialMissile(p2PosX, -1);
                }} else if (shotType < 60) {{
                    // Tiro supers√¥nico
                    shot = team2.shootSupersonic(p2PosX, -1);
                }} else {{
                    // Tiro normal
                    shot = team2.shoot(p2PosX, -1);
                }}

                if (shot != null) {{
                    // Garantir que a altitude do proj√©til n√£o exceda o campo de batalha
                    shot.posY = Math.min(shot.posY, battlefieldHeight - 1);
                    projectiles.add(shot);
                }}
            }}

            // Posicionar aeronaves no campo de batalha com cores
            battlefield[team1.getPositionY()][p1PosX] = "\u001B[34m" + team1.symbol + "\u001B[0m";  // Azul para Time 1
            battlefield[team2.getPositionY()][p2PosX] = "\u001B[31m" + team2.symbol + "\u001B[0m";  // Vermelho para Time 2

            // Mover proj√©teis e verificar colis√µes
            Iterator<Projectile> iterator = projectiles.iterator();
            while (iterator.hasNext()) {{
                Projectile p = iterator.next();
                p.move();

                // Verificar colis√µes com Time 1
                if (p.posX == p1PosX && p.posY == team1.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("<[=-")) {{ // M√≠ssil nuclear do Time 2
                        damage = team2.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 2 atingiu o Time 1!");
                    }} else if (p.symbol.contains("‚áá")) {{ // Tiro duplo do Time 2
                        damage = team2.doubleShotPower;
                    }} else if (p.symbol.equals("<=")) {{
                        damage = team2.missilePower;
                    }} else if (p.symbol.equals("<<")) {{
                        damage = team2.supersonicPower;
                    }} else {{
                        damage = team2.shotPower;
                    }}

                    if (random.nextInt(100) >= team1.stealthChance) {{
                        team1.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 1 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 1 esquivou!");
                        if (team1.radar > 0) {{
                            System.out.println("üì° Radar do Time 1 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Verificar colis√µes com Time 2
                if (p.posX == p2PosX && p.posY == team2.getPositionY()) {{
                    int damage = 0;

                    // Verificar se o proj√©til tem poder personalizado
                    if (p.getPower() > 0) {{
                        damage = p.getPower();
                    }} else if (p.symbol.contains("-]=>")) {{ // M√≠ssil nuclear do Time 1
                        damage = team1.nuclearPower * 2;
                        System.out.println("üí•üí•üí• M√çSSIL NUCLEAR do Time 1 atingiu o Time 2!");
                    }} else if (p.symbol.contains("‚áâ")) {{ // Tiro duplo do Time 1
                        damage = team1.doubleShotPower;
                    }} else if (p.symbol.equals("=>")) {{
                        damage = team1.missilePower;
                    }} else if (p.symbol.equals(">>")) {{
                        damage = team1.supersonicPower;
                    }} else {{
                        damage = team1.shotPower;
                    }}

                    if (random.nextInt(100) >= team2.stealthChance) {{
                        team2.takeDamage(damage);
                        System.out.println("üí• Aeronave do Time 2 atingida! -" + damage + " pontos");
                    }} else {{
                        System.out.println("üëª Aeronave do Time 2 esquivou!");
                        if (team2.radar > 0) {{
                            System.out.println("üì° Radar do Time 2 detectou o proj√©til!");
                        }}
                    }}
                    iterator.remove();
                    continue;
                }}

                // Remover proj√©teis fora dos limites
                if (p.isOutOfBounds(screenWidth)) {{
                    iterator.remove();
                    continue;
                }}

                // Mostrar proj√©teis no campo de batalha com cores
                if (p.posX >= 0 && p.posX < screenWidth && p.posY >= 0 && p.posY < battlefieldHeight) {{
                    // Adicionar cores aos proj√©teis baseado na dire√ß√£o
                    if (p.direction > 0) {{
                        battlefield[p.posY][p.posX] = "\u001B[34m" + p.symbol + "\u001B[0m";  // Azul para Time 1
                    }} else {{
                        battlefield[p.posY][p.posX] = "\u001B[31m" + p.symbol + "\u001B[0m";  // Vermelho para Time 2
                    }}
                }}
            }}  // Fechamento do while

            // Mostrar campo de batalha
            for (int row = 0; row < battlefieldHeight; row++) {{
                for (int i = 0; i < screenWidth; i++) {{
                    System.out.print(battlefield[row][i]);
                }}
                System.out.println();
            }}

            // Mostrar status de vida
            System.out.println("‚ù§Ô∏è Vida Time 1: " + team1.getHealth() + " | ‚ù§Ô∏è Vida Time 2: " + team2.getHealth());
            System.out.flush();

            // Pausa para visualiza√ß√£o
            try {{
                Thread.sleep(200);
            }} catch (InterruptedException e) {{
                System.err.println("Erro na pausa: " + e.getMessage());
            }}
        }}

        if (team1.isAlive()) {{
            System.out.println("üèÜ Time 1 venceu!");
        }} else {{
            System.out.println("üèÜ Time 2 venceu!");
        }}
        System.out.flush();
    }}
}}"""

    # Salvar os arquivos Java
    with open(aircraft_path, "w") as f:
        f.write(aircraft_code)
    with open(projectile_path, "w") as f:
        f.write(projectile_code)
    with open(class1_path, "w") as f1:
        f1.write(code1)
    with open(class2_path, "w") as f2:
        f2.write(code2)
    with open(main_path, "w") as f_main:
        f_main.write(battle_main_code)

    try:
        # Compilar os arquivos Java
        for java_file in [aircraft_path, projectile_path, class1_path, class2_path, main_path]:
            compile_result = subprocess.run(["javac", "-cp", "combat_classes", "-d", "combat_classes", java_file], capture_output=True, text=True)
            if compile_result.returncode != 0:
                return f"‚ùå Erro na compila√ß√£o:\n{compile_result.stderr}"

        # Executar a simula√ß√£o
        process = subprocess.Popen(
            ["java", "-cp", "combat_classes", "BattleMain"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        # Usar deque para manter os √∫ltimos turnos na visualiza√ß√£o
        from collections import deque
        turnos = deque(maxlen=4)  # √öltimos 5 turnos para visualiza√ß√£o fluida

        # Guardar sa√≠da completa
        saida_completa = ""

        turno_atual = ""
        coletando_turno = False

        # Para detectar o final
        resultado_final = None

        for line in iter(process.stdout.readline, ""):
            saida_completa += line

            # Detectar novo turno
            if "=== NOVO TURNO ===" in line:
                if turno_atual:
                    turnos.append(turno_atual)
                turno_atual = line
                coletando_turno = True
            elif coletando_turno:
                turno_atual += line

            # Verificar se √© o resultado final
            if "venceu" in line:
                resultado_final = line

            # Atualizar a cada turno (visualiza√ß√£o fluida com poucos turnos)
            texto = "".join(list(turnos)) + turno_atual

            # Convers√£o de cores
            formatted_texto = texto.replace("\033[31m", "<span style='color:red;'>")
            formatted_texto = formatted_texto.replace("\033[34m", "<span style='color:blue;'>")
            formatted_texto = formatted_texto.replace("\033[32m", "<span style='color:green;'>")
            formatted_texto = formatted_texto.replace("\033[0m", "</span>")

            # Script de scroll mais agressivo
            scroll_js = """
            <script>
            (function() {
                function forceScrollBottom() {
                    const container = document.getElementById('battle-container');
                    if (container) {
                        // For√ßa scroll para o final com valor extra alto
                        container.scrollTop = container.scrollHeight * 10;

                        // Repete para garantir
                        setTimeout(() => {
                            container.scrollTop = container.scrollHeight * 10;
                        }, 50);
                        setTimeout(() => {
                            container.scrollTop = container.scrollHeight * 10;
                        }, 100);
                    }
                }

                // Executa imediatamente e repetidamente
                forceScrollBottom();

                // Continua verificando
                const scrollInterval = setInterval(forceScrollBottom, 100);
                setTimeout(() => { clearInterval(scrollInterval); }, 2000);

                // Observer para detectar mudan√ßas
                const observer = new MutationObserver(forceScrollBottom);
                const container = document.getElementById('battle-container');
                if (container) {
                    observer.observe(container, { childList: true, subtree: true });
                }
            })();
            </script>
            """

            html_output = f"""
            <div id="battle-container" style="height:400px; overflow:auto; border:1px solid #ccc; padding:10px;
                                             font-family:monospace; white-space:pre; background-color:#f8f8f8;">
                {formatted_texto}
            </div>
            {scroll_js}
            """

            yield html_output

            # Pausa pequena entre atualiza√ß√µes
            import time
            time.sleep(0.05)

        # Ao final, mostrar resultado destacado e hist√≥rico completo
        if resultado_final:
            # Formatar toda a sa√≠da
            formatted_saida = saida_completa.replace("\033[31m", "<span style='color:red;'>")
            formatted_saida = formatted_saida.replace("\033[34m", "<span style='color:blue;'>")
            formatted_saida = formatted_saida.replace("\033[32m", "<span style='color:green;'>")
            formatted_saida = formatted_saida.replace("\033[0m", "</span>")

            # Detectar o vencedor para colorir o resultado
            vencedor = "Time 1" if "Time 1 venceu" in resultado_final else "Time 2"
            cor = "blue" if vencedor == "Time 1" else "red"

            # Script de scroll final mais poderoso
            final_scroll_js = """
            <script>
            (function() {
                function finalForceScroll() {
                    const container = document.querySelector('#historico-completo');
                    if (container) {
                        container.scrollTop = container.scrollHeight * 20;
                    }
                }

                // Executa muitas vezes
                finalForceScroll();
                for (let i = 1; i <= 20; i++) {
                    setTimeout(finalForceScroll, i * 100);
                }

                // Continua verificando
                const scrollInterval = setInterval(finalForceScroll, 200);
                setTimeout(() => { clearInterval(scrollInterval); }, 5000);
            })();
            </script>
            """

            # Montar o HTML final com resultado e hist√≥rico completo
            final_html = f"""
            <div>
                <div style="padding:15px; background-color:#e9f7e9; border:2px solid #4CAF50;
                            margin:15px 0; text-align:center; border-radius:5px;">
                    <h3 style="color:{cor}; margin:0; font-size:24px;">üèÜ {vencedor} VENCEU! üèÜ</h3>
                </div>

                <h4>Hist√≥rico Completo da Batalha:</h4>

                <div id="historico-completo" style="height:500px; overflow:auto; border:1px solid #ccc; padding:10px;
                           font-family:monospace; white-space:pre; background-color:#f8f8f8;">
                    {formatted_saida}
                </div>
                {final_scroll_js}
            </div>
            """

            yield final_html

    except Exception as e:
        yield f"‚ö† Erro inesperado: {str(e)}"

def render_battlefield(turnos, turno_atual, resultado_final=None, final=False):
    # Construir o texto: turnos anteriores + turno atual + resultado final
    texto = "".join(list(turnos)) + turno_atual
    if resultado_final and resultado_final not in texto:
        texto += resultado_final

    # Convers√£o de cores
    texto = texto.replace("\033[31m", "<span style='color:red;'>")
    texto = texto.replace("\033[34m", "<span style='color:blue;'>")
    texto = texto.replace("\033[32m", "<span style='color:green;'>")
    texto = texto.replace("\033[0m", "</span>")

    # Script de scroll aprimorado para for√ßar scroll mesmo durante atualiza√ß√µes r√°pidas
    scroll_js = """
    <script>
    (function() {
        function forceScrollToBottom() {
            const container = document.getElementById('battle-container');
            if (container) {
                // Use um valor bem alto para garantir que v√° at√© o fundo
                container.scrollTop = container.scrollHeight * 10;

                // Tenta novamente com diferentes intervalos
                setTimeout(() => { container.scrollTop = container.scrollHeight * 10; }, 50);
                setTimeout(() => { container.scrollTop = container.scrollHeight * 10; }, 150);
                setTimeout(() => { container.scrollTop = container.scrollHeight * 10; }, 300);
            }
        }

        // Executa imediatamente
        forceScrollToBottom();

        // Configura um intervalo para verifica√ß√£o cont√≠nua do scroll
        const scrollInterval = setInterval(forceScrollToBottom, 100);
        setTimeout(() => { clearInterval(scrollInterval); }, 2000);

        // Observa mudan√ßas no conte√∫do para reajustar o scroll
        const observer = new MutationObserver(forceScrollToBottom);
        const container = document.getElementById('battle-container');
        if (container) {
            observer.observe(container, { childList: true, subtree: true });
        }
    })();
    </script>
    """

    # Script ainda mais agressivo para o final
    if final:
        scroll_js = """
        <script>
        (function() {
            function finalScroll() {
                const container = document.getElementById('battle-container');
                if (container) {
                    // Valor extremamente alto para garantir o scroll at√© o final
                    container.scrollTop = container.scrollHeight * 20;
                }
            }

            // Executa muitas vezes com diferentes intervalos
            finalScroll();
            for (let i = 1; i <= 20; i++) {
                setTimeout(finalScroll, i * 100);
            }

            // Continua verificando por um per√≠odo prolongado
            const scrollInterval = setInterval(finalScroll, 200);
            setTimeout(() => { clearInterval(scrollInterval); }, 5000);

            // Observer para detectar mudan√ßas e manter o scroll no final
            const observer = new MutationObserver(finalScroll);
            const container = document.getElementById('battle-container');
            if (container) {
                observer.observe(container, { childList: true, subtree: true });
            }
        })();
        </script>
        """

    return f"""
    <div id="battle-container" style="height:400px; overflow:auto; border:1px solid #ccc; padding:10px;
                                     font-family:monospace; white-space:pre; background-color:#f8f8f8;
                                     scroll-behavior: smooth; display:block; visibility:visible;">
        {texto}
    </div>
    {scroll_js}
    """

def render_historico_completo(historico, resultado_final=None):
    # Construir o texto completo
    texto_completo = "".join(historico)
    if resultado_final and resultado_final not in texto_completo:
        texto_completo += resultado_final

    # Convers√£o de cores
    texto_completo = texto_completo.replace("\033[31m", "<span style='color:red;'>")
    texto_completo = texto_completo.replace("\033[34m", "<span style='color:blue;'>")
    texto_completo = texto_completo.replace("\033[32m", "<span style='color:green;'>")
    texto_completo = texto_completo.replace("\033[0m", "</span>")

    # Destacar resultado
    if resultado_final:
        vencedor = "Time 1" if "Time 1 venceu" in resultado_final else "Time 2"
        cor = "blue" if vencedor == "Time 1" else "red"
        resultado_html = f'<div style="padding:10px; background-color:#e9f7e9; border:2px solid #4CAF50; margin:10px 0; text-align:center;"><h3 style="color:{cor}; margin:0;">üèÜ {vencedor} VENCEU! üèÜ</h3></div>'
    else:
        resultado_html = ""

    # Script de scroll para o hist√≥rico expandido
    scroll_js = """
    <script>
    function scrollHistorico() {
        const historico = document.getElementById('historico-completo');
        if (historico && historico.style.display === 'block') {
            historico.scrollTop = historico.scrollHeight * 10;

            // Tentar m√∫ltiplas vezes
            setTimeout(() => { historico.scrollTop = historico.scrollHeight * 10; }, 100);
            setTimeout(() => { historico.scrollTop = historico.scrollHeight * 10; }, 300);
        }
    }

    function toggleHistorico() {
        var el = document.getElementById('historico-completo');
        var btn = el.previousElementSibling;

        if (el.style.display === 'none') {
            el.style.display = 'block';
            btn.textContent = 'Ocultar hist√≥rico completo';

            // Scroll para o final quando expandir com atrasos e repeti√ß√µes
            for (let i = 1; i <= 10; i++) {
                setTimeout(scrollHistorico, i * 100);
            }
        } else {
            el.style.display = 'none';
            btn.textContent = 'Mostrar hist√≥rico completo da batalha';
        }
    }
    </script>
    """

    # Hist√≥rico expans√≠vel com bot√£o
    return f"""
    {resultado_html}
    <div style="margin-top:10px;">
        <button onclick="toggleHistorico()" style="padding:5px 10px; margin-bottom:10px; cursor:pointer;">
            Mostrar hist√≥rico completo da batalha
        </button>

        <div id="historico-completo" style="display:none; height:500px; overflow:auto; border:1px solid #ccc;
                                         padding:10px; font-family:monospace; white-space:pre; background-color:#f8f8f8;">
            {texto_completo}
        </div>
    </div>
    {scroll_js}
    """

# Interface Gradio Ajustada com Configura√ß√µes e Bot√µes para Templates
with gr.Blocks() as app:
    gr.Markdown("# ‚Øêüõ¶üõß JAVA-Aircraft-Combat - Time 1 vs Time 2")

    gr.Markdown("""
    ## Instru√ß√µes R√°pidas

    1. Use os bot√µes "Carregar Template" para obter um modelo edit√°vel para cada time
    2. Personalize os atributos da aeronave (m√°ximo de 100 pontos)
    3. Configure a arena no painel de configura√ß√µes abaixo se desejar
    4. Clique em "üî• Combate!" para iniciar a batalha

    **NOVIDADES**: Agora suas aeronaves podem ter radar para detectar proj√©teis, tiro duplo para atacar em duas altitudes diferentes e at√© m√≠sseis nucleares para dano massivo!
    """)

    with gr.Row():
        with gr.Column():
            team1_code = gr.Textbox(label="üü¶ C√≥digo Time 1", lines=20)
            team1_template_btn = gr.Button("üìù Carregar Template Time 1")

        with gr.Column():
            team2_code = gr.Textbox(label="üü• C√≥digo Time 2", lines=20)
            team2_template_btn = gr.Button("üìù Carregar Template Time 2")

    # Fun√ß√µes para carregar templates
    def load_team1_template():
        return TEAM1_TEMPLATE

    def load_team2_template():
        return TEAM2_TEMPLATE

    # Conectar bot√µes √†s fun√ß√µes
    team1_template_btn.click(load_team1_template, inputs=[], outputs=team1_code)
    team2_template_btn.click(load_team2_template, inputs=[], outputs=team2_code)

    with gr.Accordion("‚öôÔ∏è Configura√ß√µes da Arena", open=False):
        with gr.Row():
            screen_width = gr.Slider(minimum=50, maximum=200, value=100, step=10,
                                   label="Largura da Tela", info="Define a largura do campo de batalha")
            battlefield_height = gr.Slider(minimum=3, maximum=7, value=3, step=1,
                                        label="Altura do Campo", info="Define o n√∫mero de linhas no campo de batalha")

        with gr.Row():
            p1_start_pos = gr.Slider(minimum=0, maximum=49, value=2, step=1,
                                   label="Posi√ß√£o Inicial Time 1", info="Define onde o Time 1 come√ßa na arena")
            p2_start_pos_auto = gr.Checkbox(label="Posicionar Time 2 automaticamente",
                                          info="Se marcado, o Time 2 ser√° posicionado no lado oposto", value=True)
            p2_start_pos = gr.Slider(minimum=51, maximum=200, value=98, step=1,
                                   label="Posi√ß√£o Inicial Time 2", info="Define onde o Time 2 come√ßa na arena",
                                   visible=False)

        # Adicionando configura√ß√µes de vida
        with gr.Row():
            team1_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 1", info="Define a vida inicial da aeronave do Time 1")
            team2_health = gr.Slider(minimum=50, maximum=500, value=100, step=10,
                                    label="‚ù§Ô∏è Vida Time 2", info="Define a vida inicial da aeronave do Time 2")

        # Bot√£o para equalizar as vidas (opcional)
        def equalize_health(health_value):
            return health_value, health_value

        equalize_btn = gr.Button("üîÑ Igualar Vidas")
        equalize_btn.click(fn=equalize_health, inputs=team1_health, outputs=[team1_health, team2_health])

        # L√≥gica para mostrar/esconder a posi√ß√£o do Time 2
        def toggle_p2_pos(auto_checked):
            return {"visible": not auto_checked}

        p2_start_pos_auto.change(toggle_p2_pos, inputs=p2_start_pos_auto, outputs=p2_start_pos)

        # Atualizar posi√ß√£o do Time 2 automaticamente com base na largura da tela
        def update_p2_pos(width):
            return width - 2

        screen_width.change(update_p2_pos, inputs=screen_width, outputs=p2_start_pos)

    # Fun√ß√£o para preparar e executar a batalha
    def prepare_battle(code1, code2, width, height, p1_pos, p2_auto, p2_pos, t1_health, t2_health):
        # Se a posi√ß√£o do Time 2 √© autom√°tica, calcule-a com base na largura
        final_p2_pos = width - 2 if p2_auto else p2_pos
        # Executar a simula√ß√£o e retornar o iterador
        for output in run_battle(code1, code2, width, height, p1_pos, final_p2_pos, t1_health, t2_health):
            yield output

    btn = gr.Button("üî• Combate!")
    #output = gr.Textbox(label="Resultado do Combate", lines=30)
    # Configurar o componente HTML com CSS adicional para visibilidade imediata
    css = """
   <style>
   #battle-result .prose {
    padding: 0 !important;
    margin: 0 !important;
    display: block !important;
    visibility: visible !important;
    }
    </style>
    """

    output = gr.HTML(label="Resultado do Combate", elem_id="battle-result", value=css)
    # Conecte o bot√£o √† fun√ß√£o preparat√≥ria com os novos par√¢metros de vida
    btn.click(fn=prepare_battle,
              inputs=[team1_code, team2_code, screen_width, battlefield_height,
                     p1_start_pos, p2_start_pos_auto, p2_start_pos,
                     team1_health, team2_health],
              outputs=output)

    # Adicionar informa√ß√µes de rodap√© com dicas simples
    gr.Markdown("""
    ### Dicas
    - Equilibre seus pontos! Uma distribui√ß√£o balanceada geralmente √© melhor.
    - Lembre que cada atributo tem limites (indicados nos coment√°rios).
    - O radar permite detectar proj√©teis inimigos e realizar manobras evasivas autom√°ticas.
    - O tiro duplo ataca em duas altitudes ao mesmo tempo, aumentando suas chances de acerto.
    - O m√≠ssil nuclear causa dano massivo, mas tem um longo cooldown de 5 turnos.
    - Use toda a altura do campo (configure nas op√ß√µes) para estrat√©gias mais interessantes!
    - Agora voc√™ pode ajustar a vida inicial das aeronaves para batalhas mais longas ou equilibrar times desiguais!

    Desenvolvido para a disciplina de Programa√ß√£o. Bons combates!
    """)

app.launch()

!javac AsciiCombat.java
!java AsciiCombat